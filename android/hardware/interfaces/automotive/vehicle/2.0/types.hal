/*
 * Copyright (C) 2016 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package android.hardware.automotive.vehicle@2.0;

/**
 * Enumerates supported data types for VehicleProperty.
 *
 * This is a bitwise flag that supposed to be used in VehicleProperty enum.
 */
enum VehiclePropertyType : int32_t {
    STRING         = 0x00100000,
    BOOLEAN        = 0x00200000,
    INT32          = 0x00400000,
    INT32_VEC      = 0x00410000,
    INT64          = 0x00500000,
    FLOAT          = 0x00600000,
    FLOAT_VEC      = 0x00610000,
    BYTES          = 0x00700000,

    /**
     * Any combination of scalar or vector types. The exact format must be
     * provided in the description of the property.
     */
    COMPLEX        = 0x00e00000,

    MASK           = 0x00ff0000
};

/**
 * Some properties may be associated with particular vehicle areas. For
 * example, VehicleProperty:DOOR_LOCK property must be associated with
 * particular door, thus this property must be marked with
 * VehicleArea:DOOR flag.
 *
 * Other properties may not be associated with particular vehicle area,
 * these kind of properties must have VehicleArea:GLOBAL flag.
 *
 * This is a bitwise flag that supposed to be used in VehicleProperty enum.
 */
enum VehicleArea : int32_t {
      GLOBAL       = 0x01000000,
      ZONE         = 0x02000000,
      WINDOW       = 0x03000000,
      MIRROR       = 0x04000000,
      SEAT         = 0x05000000,
      DOOR         = 0x06000000,

      MASK         = 0x0f000000,
};

/**
 * Enumerates property groups.
 *
 * This is a bitwise flag that supposed to be used in VehicleProperty enum.
 */
enum VehiclePropertyGroup : int32_t {
    /**
     * Properties declared in AOSP must have this flag.
     */
    SYSTEM         = 0x10000000,

    /**
     * Properties declared by vendors must have this flag.
     */
    VENDOR         = 0x20000000,

    MASK           = 0xf0000000,
};

/**
 * Declares all vehicle properties. VehicleProperty has a bitwise structure.
 * Each property must have:
 *   - an unique id from range 0x0100 - 0xffff
 *   - associated data type using VehiclePropertyType
 *   - property group (VehiclePropertyGroup)
 *   - vehicle area (VehicleArea)
 *
 * Vendors are allowed to extend this enum with their own properties. In this
 * case they must use VehiclePropertyGroup:VENDOR flag when property is
 * declared.
 */
enum VehicleProperty: int32_t {

    /** Undefined property. */
    INVALID = 0x00000000,

    /**
     * VIN of vehicle
     *
     * @change_mode VehiclePropertyChangeMode:STATIC
     * @access VehiclePropertyAccess:READ
     */
    INFO_VIN= (
        0x0100
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:STRING
        | VehicleArea:GLOBAL),

    /**
     * Maker name of vehicle
     *
     * @change_mode VehiclePropertyChangeMode:STATIC
     * @access VehiclePropertyAccess:READ
     */
    INFO_MAKE = (
        0x0101
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:STRING
        | VehicleArea:GLOBAL),

    /**
     * Model of vehicle
     *
     * @change_mode VehiclePropertyChangeMode:STATIC
     * @access VehiclePropertyAccess:READ
     */
    INFO_MODEL = (
        0x0102
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:STRING
        | VehicleArea:GLOBAL),

    /**
     * Model year of vehicle.
     *
     * @change_mode VehiclePropertyChangeMode:STATIC
     * @access VehiclePropertyAccess:READ
     * @unit VehicleUnit:YEAR
     */
    INFO_MODEL_YEAR = (
        0x0103
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:GLOBAL),

    /**
     * Fuel capacity of the vehicle
     *
     * @change_mode VehiclePropertyChangeMode:STATIC
     * @access VehiclePropertyAccess:READ
     * @unit VehicleUnit:MILLILITER
     */
    INFO_FUEL_CAPACITY = (
        0x0104
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:FLOAT
        | VehicleArea:GLOBAL),

    /**
     * Current odometer value of the vehicle
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE | VehiclePropertyChangeMode:CONTINUOUS
     * @access VehiclePropertyAccess:READ
     * @unit VehicleUnit:KILOMETER
     */
    PERF_ODOMETER = (
        0x0204
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:FLOAT
        | VehicleArea:GLOBAL),

    /**
     * Speed of the vehicle
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE|VehiclePropertyChangeMode:CONTINUOUS
     * @access VehiclePropertyAccess:READ
     * @unit VehicleUnit:METER_PER_SEC
     */
    PERF_VEHICLE_SPEED = (
        0x0207
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:FLOAT
        | VehicleArea:GLOBAL),

    /**
     * Temperature of engine coolant
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE|VehiclePropertyChangeMode:CONTINUOUS
     * @access VehiclePropertyAccess:READ
     * @unit VehicleUnit:CELSIUS
     */
    ENGINE_COOLANT_TEMP = (
        0x0301
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:FLOAT
        | VehicleArea:GLOBAL),

    /**
     * Temperature of engine oil
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE|VehiclePropertyChangeMode:CONTINUOUS
     * @access VehiclePropertyAccess:READ
     * @unit VehicleUnit:CELSIUS
     */
    ENGINE_OIL_TEMP = (
        0x0304
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:FLOAT
        | VehicleArea:GLOBAL),

    /**
     * Engine rpm
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE|VehiclePropertyChangeMode:CONTINUOUS
     * @access VehiclePropertyAccess:READ
     * @unit VehicleUnit:RPM
     */
    ENGINE_RPM = (
        0x0305
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:FLOAT
        | VehicleArea:GLOBAL),

    /**
     * Reports wheel ticks
     *
     * The first four elements represent ticks for individual wheels in the
     * following order: front left, front right, rear right, rear left.  All
     * tick counts are cumulative.  Tick counts increment when the vehicle
     * moves forward, and decrement when vehicles moves in reverse.  The ticks
     * should be reset to 0 when the vehicle is started by the user.
     *
     * The next element in the vector is a reset count.  A reset indicates
     * previous tick counts are not comparable with this and future ones.  Some
     * sort of discontinuity in tick counting has occurred.
     *
     *  int64Values[0] = reset count
     *  int64Values[1] = front left ticks
     *  int64Values[2] = front right ticks
     *  int64Values[3] = rear right ticks
     *  int64Values[4] = rear left ticks
     *
     * configArray is used to indicate the micrometers-per-wheel-tick value as well as
     * which wheels are supported.  configArray is set as follows:
     *
     *  configArray[0], bits [0:3] = supported wheels.  Uses enum Wheel.
     *  configArray[1] = micrometers per front left wheel tick
     *  configArray[2] = micrometers per front right wheel tick
     *  configArray[3] = micrometers per rear right wheel tick
     *  configArray[4] = micrometers per rear left wheel tick
     *
     * NOTE:  If a wheel is not supported, its value shall always be set to 0.
     *
     * VehiclePropValue.timestamp must be correctly filled in.
     *
     * @change_mode VehiclePropertyChangeMode:CONTINUOUS
     * @access VehiclePropertyAccess:READ
     *
     * @since o.mr1
     */
    WHEEL_TICK = (
      0x0306
      | VehiclePropertyGroup:SYSTEM
      | VehiclePropertyType:COMPLEX
      | VehicleArea:GLOBAL),


    /**
     * Currently selected gear
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ
     * @data_enum VehicleGear
     */
    GEAR_SELECTION = (
        0x0400
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:GLOBAL),

    /**
     * Current gear. In non-manual case, selected gear does not necessarily
     * match the current gear.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ
     * @data_enum VehicleGear
     */
    CURRENT_GEAR = (
        0x0401
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:GLOBAL),

    /**
     * Parking brake state.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ
     */
    PARKING_BRAKE_ON = (
        0x0402
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:BOOLEAN
        | VehicleArea:GLOBAL),

    /**
     * Driving status policy.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ
     * @data_enum VehicleDrivingStatus
     */
    DRIVING_STATUS = (
        0x0404
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:GLOBAL),

    /**
     * Warning for fuel low level.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ
     */
    FUEL_LEVEL_LOW = (
        0x0405
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:BOOLEAN
        | VehicleArea:GLOBAL),

    /**
     * Night mode or not.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ
     */
    NIGHT_MODE = (
        0x0407
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:BOOLEAN
        | VehicleArea:GLOBAL),

    /**
     * State of the vehicles turn signals
     *
     * Values from VehicleTurnSignal
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ
     */
    TURN_SIGNAL_STATE = (
        0x0408
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:GLOBAL),

    /**
     * Represents ignition state
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ
     */
    IGNITION_STATE = (
        0x0409
            | VehiclePropertyGroup:SYSTEM
            | VehiclePropertyType:INT32
            | VehicleArea:GLOBAL),

    /**
     * ABS is active.  Set to true whenever ABS is activated.  Reset to false when ABS is off.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ
     *
     * @since o.mr1
     */
    ABS_ACTIVE = (
        0x040A
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:BOOLEAN
        | VehicleArea:GLOBAL),

    /**
     * Traction Control is active.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ
     *
     * @since o.mr1
     */
    TRACTION_CONTROL_ACTIVE = (
        0x040B
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:BOOLEAN
        | VehicleArea:GLOBAL),

    /**
     * Fan speed setting
     *
     * IVehicle#set may return StatusCode::NOT_AVAILABLE and IVehicle#get is not
     * guaranteed to work if HVAC unit is off.  See HVAC_POWER_ON property for
     * details.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    HVAC_FAN_SPEED = (
        0x0500
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:ZONE),

    /**
     * Fan direction setting
     *
     * IVehicle#set may return StatusCode::NOT_AVAILABLE and IVehicle#get is not
     * guaranteed to work if HVAC unit is off.  See HVAC_POWER_ON property for
     * details.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     * @data_enum VehicleHvacFanDirection
     */
    HVAC_FAN_DIRECTION = (
        0x0501
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:ZONE),

    /**
     * HVAC current temperature.
     *
     * IVehicle#set may return StatusCode::NOT_AVAILABLE and IVehicle#get is not
     * guaranteed to work if HVAC unit is off.  See HVAC_POWER_ON property for
     * details.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    HVAC_TEMPERATURE_CURRENT = (
        0x0502
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:FLOAT
        | VehicleArea:ZONE),

    /**
     * HVAC, target temperature set.
     *
     * IVehicle#set may return StatusCode::NOT_AVAILABLE and IVehicle#get is not
     * guaranteed to work if HVAC unit is off.  See HVAC_POWER_ON property for
     * details.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    HVAC_TEMPERATURE_SET = (
        0x0503
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:FLOAT
        | VehicleArea:ZONE),

    /**
     * On/off defrost
     *
     * IVehicle#set may return StatusCode::NOT_AVAILABLE and IVehicle#get is not
     * guaranteed to work if HVAC unit is off.  See HVAC_POWER_ON property for
     * details.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    HVAC_DEFROSTER = (
        0x0504
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:BOOLEAN
        | VehicleArea:WINDOW),

    /**
     * On/off AC
     *
     * IVehicle#set may return StatusCode::NOT_AVAILABLE and IVehicle#get is not
     * guaranteed to work if HVAC unit is off.  See HVAC_POWER_ON property for
     * details.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     * @config_flags Supported zones
     */
    HVAC_AC_ON = (
        0x0505
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:BOOLEAN
        | VehicleArea:ZONE),

    /**
     * On/off max AC
     *
     * IVehicle#set may return StatusCode::NOT_AVAILABLE and IVehicle#get is not
     * guaranteed to work if HVAC unit is off.  See HVAC_POWER_ON property for
     * details.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    HVAC_MAX_AC_ON = (
        0x0506
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:BOOLEAN
        | VehicleArea:ZONE),

    /**
     * On/off max defrost
     *
     * IVehicle#set may return StatusCode::NOT_AVAILABLE and IVehicle#get is not
     * guaranteed to work if HVAC unit is off.  See HVAC_POWER_ON property for
     * details.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    HVAC_MAX_DEFROST_ON = (
        0x0507
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:BOOLEAN
        | VehicleArea:ZONE),

    /**
     * On/off re-circulation
     *
     * IVehicle#set may return StatusCode::NOT_AVAILABLE and IVehicle#get is not
     * guaranteed to work if HVAC unit is off.  See HVAC_POWER_ON property for
     * details.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    HVAC_RECIRC_ON = (
        0x0508
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:BOOLEAN
        | VehicleArea:ZONE),

    /**
     * On/off dual. This must be defined per each row.
     *
     * IVehicle#set may return StatusCode::NOT_AVAILABLE and IVehicle#get is not
     * guaranteed to work if HVAC unit is off.  See HVAC_POWER_ON property for
     * details.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    HVAC_DUAL_ON = (
        0x0509
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:BOOLEAN
        | VehicleArea:ZONE),

    /**
     * On/off automatic mode
     *
     * IVehicle#set may return StatusCode::NOT_AVAILABLE and IVehicle#get is not
     * guaranteed to work if HVAC unit is off.  See HVAC_POWER_ON property for
     * details.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    HVAC_AUTO_ON = (
        0x050A
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:BOOLEAN
        | VehicleArea:ZONE),

    /**
     * Seat temperature
     *
     * Negative values indicate cooling.
     * 0 indicates off.
     * Positive values indicate heating.
     *
     * Some vehicles may have multiple levels of heating and cooling. The
     * min/max range defines the allowable range and number of steps in each
     * direction.
     *
     * IVehicle#set may return StatusCode::NOT_AVAILABLE and IVehicle#get is not
     * guaranteed to work if HVAC unit is off.  See HVAC_POWER_ON property for
     * details.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    HVAC_SEAT_TEMPERATURE = (
        0x050B
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:SEAT),

    /**
     * Side Mirror Heat
     *
     * Increase values denote higher heating levels for side mirrors.
     * 0 indicates heating is turned off.
     *
     * IVehicle#set may return StatusCode::NOT_AVAILABLE and IVehicle#get is not
     * guaranteed to work if HVAC unit is off.  See HVAC_POWER_ON property for
     * details.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    HVAC_SIDE_MIRROR_HEAT = (
        0x050C
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:MIRROR),

    /**
     * Steering Wheel Temperature
     *
     * Sets the temperature for the steering wheel
     * Positive value indicates heating.
     * Negative value indicates cooling.
     * 0 indicates temperature control is off.
     *
     * IVehicle#set may return StatusCode::NOT_AVAILABLE and IVehicle#get is not
     * guaranteed to work if HVAC unit is off.  See HVAC_POWER_ON property for
     * details.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    HVAC_STEERING_WHEEL_TEMP = (
        0x050D
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:GLOBAL),

    /**
     * Temperature units
     *
     * Indicates whether the temperature is in Celsius, Fahrenheit, or a
     * different unit from VehicleUnit enum.
     * This parameter affects all HVAC temperatures in the system.
     *
     * IVehicle#get is not guaranteed to work if HVAC unit is off.  See
     * HVAC_POWER_ON property for details.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ
     */
    HVAC_TEMPERATURE_UNITS = (
        0x050E
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:ZONE),

    /**
     * Actual fan speed
     *
     * IVehicle#get is not guaranteed to work if HVAC unit is off.  See
     * HVAC_POWER_ON property for details.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ
     */
    HVAC_ACTUAL_FAN_SPEED_RPM = (
        0x050F
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:ZONE),

    /**
     * Represents power state for HVAC. Some HVAC properties must require
     * matching power to be turned on to get out of OFF state. For non-zoned
     * HVAC properties, VEHICLE_ALL_ZONE corresponds to global power state.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     * @config_string list of HVAC properties whose power is controlled by this
     *                property. Format is hexa-decimal number (0x...) separated
     *                by comma like "0x500,0x503". All zones defined in these
     *                affected properties must be available in the property.
     */
    HVAC_POWER_ON = (
        0x0510
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:BOOLEAN
        | VehicleArea:ZONE),

    /**
     * Fan Positions Available
     *
     * This is a bit mask of fan positions available for the zone.  Each entry in
     * vehicle_hvac_fan_direction is selected by bit position.  For instance, if
     * only the FAN_DIRECTION_FACE (0x1) and FAN_DIRECTION_DEFROST (0x4) are available,
     * then this value shall be set to 0x12.
     *
     * 0x12 = (1 << 1) | (1 << 4)
     *
     * @change_mode VehiclePropertyChangeMode:STATIC
     * @access VehiclePropertyAccess:READ
     */
    HVAC_FAN_DIRECTION_AVAILABLE = (
        0x0511
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:ZONE),

    /**
     * Automatic re-circulation on/off
     *
     * IVehicle#set and IVehicle#get must return StatusCode::NOT_AVAILABLE when HVAC unit is off.
     * See HVAC_POWER_ON property for details.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     *
     * @since o.mr1
     */
    HVAC_AUTO_RECIRC_ON = (
        0x0512
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:BOOLEAN
        | VehicleArea:ZONE),

    /**
     * Outside temperature
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE|VehiclePropertyChangeMode:CONTINUOUS
     * @access VehiclePropertyAccess:READ
     * @unit VehicleUnit:CELSIUS
     */
    ENV_OUTSIDE_TEMPERATURE = (
        0x0703
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:FLOAT
        | VehicleArea:GLOBAL),

    /**
     * Cabin temperature
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE|VehiclePropertyChangeMode:CONTINUOUS
     * @access VehiclePropertyAccess:READ
     * @unit VehicleUnit:CELSIUS
     */
    ENV_CABIN_TEMPERATURE = (
        0x0704
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:FLOAT
        | VehicleArea:GLOBAL),

    /**
     * Radio presets stored on the Car radio module. The data type used is int32
     * array with the following fields:
     * <ul>
     *    <li> int32Values[0]: Preset number </li>
     *    <li> int32Values[1]: Band type (see #RADIO_BAND_FM in
     *    system/core/include/system/radio.h).
     *    <li> int32Values[2]: Channel number </li>
     *    <li> int32Values[3]: Sub channel number </li>
     * </ul>
     *
     * NOTE: When getting a current preset config ONLY set preset number (i.e.
     * int32Values[0]). For setting a preset other fields are required.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     * @config_flags Number of presets supported
     */
    RADIO_PRESET = (
        0x0801
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32_VEC
        | VehicleArea:GLOBAL),

    /**
     * Represents audio focus state of Android side. Note that car's audio
     * module must own audio focus and grant audio focus to Android side when
     * requested by Android side. The focus has both per stream characteristics
     * and global characteristics.
     *
     * Focus request (get of this property) must take the following form with indices defined
     * by VehicleAudioFocusIndex:
     *   int32Values[0]: VehicleAudioFocusRequest type
     *   int32Values[1]: bit flags of streams requested by this focus request.
     *                   There can be up to 32 streams.
     *   int32Values[2]: External focus state flags. For request, only flag like
     *                   VehicleAudioExtFocusFlag#PLAY_ONLY_FLAG or
     *                   VehicleAudioExtFocusFlag#MUTE_MEDIA_FLAG can be
     *                   used.
     *                   VehicleAudioExtFocusFlag#PLAY_ONLY_FLAG is for case
     *                   like radio where android side app still needs to hold
     *                   focus but playback is done outside Android.
     *                   VehicleAudioExtFocusFlag#MUTE_MEDIA_FLAG is for
     *                   muting media channel including radio.
     *                   VehicleAudioExtFocusFlag#PLAY_ONLY_FLAG can be set
     *                   even if android side releases focus (request type
     *                   REQUEST_RELEASE). In that case, audio module must
     *                   maintain mute state until user's explicit action to
     *                   play some media.
     *   int32Values[3]: Audio contexts wishing to be active. Use combination of
     *                   flags from VehicleAudioContextFlag.
     *                   This can be used as a hint to adjust audio policy or
     *                   other policy decision.
     *                   Note that there can be multiple context active at the
     *                   same time. And android can send the same focus request
     *                   type gain due to change in audio contexts.
     * Note that each focus request can request multiple streams that is
     * expected to be used for the current request. But focus request itself
     * is global behavior as GAIN or GAIN_TRANSIENT expects all sounds played
     * by car's audio module to stop. Note that stream already allocated to
     * android before this focus request must not be affected by focus
     * request.
     *
     * Focus response (set and subscription callback for this property) must
     * take the following form with indices defined by VehicleAudioFocusIndex:
     *   int32Values[0]: VehicleAudioFocusState type
     *   int32Values[1]: bit flags of streams allowed.
     *   int32Values[2]: External focus state: bit flags of currently active
     *                   audio focus in car side (outside Android). Active
     *                   audio focus does not necessarily mean currently
     *                   playing, but represents the state of having focus or
     *                   waiting for focus (pause state).
     *                   One or combination of flags from
     *                   VehicleAudioExtFocusFlag.
     *                   0 means no active audio focus holder outside Android.
     *                   The state must have following values for each
     *                   VehicleAudioFocusState:
     *                   GAIN: VehicleAudioExtFocusFlag#PLAY_ONLY_FLAG
     *                       when radio is active in Android side. Otherwise,
     *                       VehicleAudioExtFocusFlag#NONE_FLAG.
     *                   GAIN_TRANSIENT: Can be
     *                       VehicleAudioExtFocusFlag#PERMANENT_FLAG or
     *                       VehicleAudioExtFocusFlag#TRANSIENT_FLAG if android
     *                       side has requested
     *                       REQUEST_GAIN_TRANSIENT_MAY_DUCK and car side is
     *                       ducking. Otherwise
     *                       VehicleAudioExtFocusFlag#NONE_FLAG.
     *                   LOSS: VehicleAudioExtFocusFlag#NONE_FLAG when no focus
     *                       is active in car side.
     *                       VehicleAudioExtFocusFlag#PERMANENT_FLAG when car
     *                       side is playing something permanent.
     *                   LOSS_TRANSIENT: must always be
     *                       VehicleAudioExtFocusFlag#PERMANENT_FLAG
     *   int32Values[3]: Audio context(s) allowed to be active. When responding positively to a
     *                   focus request from Android, the request's original context must be
     *                   repeated here. When taking focus away, or denying a request, the
     *                   rejected or stopped context would have its corresponding bit cleared.
     *
     * A focus response must be sent per each focus request even if there is
     * no change in focus state. This can happen in case like focus request
     * only involving context change where android side still needs matching
     * focus response to confirm that audio module has made necessary changes.
     *
     * If car does not support AUDIO_FOCUS, focus is assumed to be granted
     * always.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    AUDIO_FOCUS = (
        0x0900
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32_VEC
        | VehicleArea:GLOBAL),

    /**
     * A property to allow external component to control audio focus. Depending on
     * H/W architecture, audio HAL may need to control audio focus while vehicle
     * HAL is still interacting with upper layer. In such case, audio HAL may set
     * this property and vehicle HAL may use this property value to decide
     * response sent through AUDIO_FOCUS property.
     * Data format is the same as AUDIO_FOCUS property.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    AUDIO_FOCUS_EXT_SYNC = (
        0x0910
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32_VEC
        | VehicleArea:GLOBAL),

    /**
     * Property to control audio volume of each audio context.
     *
     * VehiclePropConfig
     *   configArray[0] : bit flags of all supported audio contexts from
     *                    VehicleAudioContextFlag. If this is 0, audio volume
     *                    is controlled per physical stream.
     *   configArray[1] : flags defined in VehicleAudioVolumeCapabilityFlag to
     *                    represent audio module's capability.
     *   configArray[2..3] : reserved
     *   configArray[4..N+3] : maximum values for each audio context, where N is
     *                         the number of audio contexts provided in
     *                         configArray[0], minimum value is always 0 which
     *                         indicates mute state.
     *
     * Data type looks like:
     *   int32Values[0] : audio context as defined in VehicleAudioContextFlag.
     *                    If only physical stream is supported
     *                    (configArray[0] == 0), this must represent physical
     *                    stream number.
     *   int32Values[1] : volume level, valid range is 0 (mute) to max level
     *                    defined in the config.
     *   int32Values[2] : One of VehicleAudioVolumeState.
     *
     * HAL implementations must check the incoming value of audio context
     * field in get call to return the right volume.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     * @config_flags all audio contexts supported.
     */
    AUDIO_VOLUME = (
        0x0901
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32_VEC
        | VehicleArea:GLOBAL),

    /**
     * Property to allow audio volume sync from external components like audio HAL.
     * Some vehicle HAL implementation may get volume control from audio HAL and in such
     * case, setting AUDIO_VOLUME_EXT_SYNC property may trigger event in AUDIO_VOLUME property.
     * Data format for this property is the same as AUDIO_VOLUME property.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     * @config_flags all audio contexts supported.
     */
    AUDIO_VOLUME_EXT_SYNC = (
        0x0911
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32_VEC
        | VehicleArea:GLOBAL),

    /**
     * Property for handling volume limit set by user. This limits maximum
     * volume that can be set per each context or physical stream.
     *
     * VehiclePropConfig
     *   configArray[0] : bit flags of all supported audio contexts. If this is
     *                    0, audio volume is controlled per physical stream.
     *   configArray[1] : flags defined in VehicleAudioVolumeCapabilityFlag
     *                    to represent audio module's capability.
     *
     * Data type looks like:
     *   int32Values[0] : audio context as defined in VehicleAudioContextFlag.
     *                    If only physical stream is supported
     *                    (configArray[0] == 0), this must represent physical
     *                    stream number.
     *   int32Values[1] : maximum volume set to the stream. If there is no
     *                    restriction, this value must be equal to
     *                    AUDIO_VOLUME's max value.
     *
     * If car does not support this feature, this property must not be
     * populated by HAL.
     * HAL implementations must check the incoming value of audio context
     * field in get call to return the right volume.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     * @config_flags all audio contexts supported.
     */
    AUDIO_VOLUME_LIMIT = (
        0x0902
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32_VEC
        | VehicleArea:GLOBAL),

    /**
     * Property to share audio routing policy of android side. This property is
     * set at startup to pass audio policy in android side down to
     * vehicle HAL and car audio module.
     *
     *   int32Values[0] : audio stream where the audio for the application
     *                    context must be routed by default. Note that this is
     *                    the default setting from system, but each app may
     *                    still use different audio stream for whatever reason.
     *   int32Values[1] : All audio contexts that must be sent through the
     *                     physical stream. Flag is defined in
     *                     VehicleAudioContextFlag.

     * Setting of this property must be done for all available physical streams
     * based on audio H/W variant information acquired from AUDIO_HW_VARIANT
     * property.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:WRITE
     */
    AUDIO_ROUTING_POLICY = (
        0x0903
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32_VEC
        | VehicleArea:GLOBAL),

    /**
     * Property to return audio H/W variant type used in this car. This is a
     * zero based index into the set of audio routing policies defined in
     * R.array.audioRoutingPolicy on CarService, which  may be overlaid to
     * support multiple variants. If this property does not exist, the default
     * audio policy must be used.
     *
     * @change_mode VehiclePropertyChangeMode:STATIC
     * @access VehiclePropertyAccess:READ
     * @config_flags Additional info on audio H/W. Must use
     *               VehicleAudioHwVariantConfigFlag for this.
     */
    AUDIO_HW_VARIANT = (
        0x0904
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:GLOBAL),

    /**
     * Property to pass hint on external audio routing. When android side
     * request focus with VehicleAudioExtFocusflag, this
     * property must be set before setting AUDIO_FOCUS property as a hint for
     * external audio source routing.
     * Note that setting this property alone must not trigger any change.
     * Audio routing must be changed only when AUDIO_FOCUS property is set.
     * Note that this property allows passing custom value as long as it is
     * defined in VehiclePropConfig#configString. This allows supporting
     * non-standard routing options through this property.
     * It is recommended to use separate name space for custom property to
     * prevent conflict in future android releases.
     * Enabling each external routing option is done by enabling each bit flag
     * for the routing.
     * This property can support up to 128 external routings.
     * To give full flexibility, there is no standard definition for each bit
     * flag and assigning each bit flag to specific routing type is decided by
     * VehiclePropConfig#configString.  VehiclePropConfig#configString has
     * format of each entry separated by ',' and each entry has format of
     * bitFlagPositon:typeString[:physicalStreamNumber].
     *  bitFlagPosition: represents which bit flag will be set to enable this
     *    routing. 0 means LSB in int32Values[0]. 31 will be MSB in
     *    int32Values[0]. 127 will MSB in int32Values[3].
     *  typeString: string representation of external routing. Some types are
     *    already defined in AUDIO_EXT_ROUTING_SOURCE_* and use them first
     *    before adding something custom. Applications will find each routing
     *    using this string.
     *  physicalStreamNumber: This part is optional and represents physical
     *    stream to android which will be disabled when this routing is enabled.
     *    If not specified, this routing must not affect physical streams to
     *    android.
     * As an example, let's assume a system with two physical streams, 0 for
     * media and 1 for nav guidance. And let's assume external routing option
     * of am fm radio, external navigation guidance, satellite radio, and one
     * custom. Let's assume that radio and satellite replaces physical stream 0
     * and external navigation replaces physical stream 1. And bit flag will be
     * assigned in the order listed above. This configuration will look like
     * this in config_string:
     *  "0:RADIO_AM_FM:0,1:EXT_NAV_GUIDANCE:1,2:RADIO_SATELLITE:0,3:com.test.SOMETHING_CUSTOM"
     * When android requests RADIO_AM_FM, int32Values[0] will be set to 0x1.
     * When android requests RADIO_SATELLITE + EXT_NAV_GUIDANCE, int32Values[0]
     * will be set to 0x2|0x4.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     * @config_string List of all avaiable external source in the system.
     */
    AUDIO_EXT_ROUTING_HINT = (
        0x0905
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32_VEC
        | VehicleArea:GLOBAL),

    /**
     * Represents state of audio stream. Audio HAL should set this when a stream is starting or
     * ending. Car service can request focus for audio played without focus. If such feature
     * is not required, this property does not need to be implemented.
     * Car service only monitors setting of this property. It is up to each vehicle HAL
     * implementation to add necessary action but default implementation will be doing nothing on
     * this propery's set from audio HAL.
     * Actual streaming of data should be done only after getting focus for the given stream from
     * car audio module. Focus can be already granted when stream is started. Focus state can be
     * monitored by monitoring AUDIO_FOCUS property. If car does not support
     * AUDIO_FOCUS property, there is no need to monitor focus as focus is assumed to be
     * granted always.
     * Data has the following format:
     *   int32_array[0] : vehicle_audio_stream_state, 0: stopped, 1: started
     *   int32_array[1] : stream number like 0, 1, 2, ...
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    AUDIO_STREAM_STATE  = (
        0x0906
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32_VEC
        | VehicleArea:GLOBAL),

    /**
     * Property to control car specific audio parameters. Each parameter is defined as string key-
     * value pair.
     * set and event notification can pass multiple parameters using the
     * following format:
     *   key1=value1;key2=value2;...
     * get call can request multiple parameters using the following format:
     *   key1;key2;...
     * Response for get call has the same format as set.
     *
     * VehiclePropConfig
     *   configString: give list of all supported keys with ; as separator. For example:
     *     key1;key2;...
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    AUDIO_PARAMETERS = (
        0x907
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:STRING
        | VehicleArea:GLOBAL),

    /**
     * Property to control power state of application processor
     *
     * It is assumed that AP's power state is controller by separate power
     * controller.
     *
     * For configuration information, VehiclePropConfig.configFlags can
     * have bit flag combining values in VehicleApPowerStateConfigFlag.
     *
     * Value format for IVehicle#get / IVehicle#subscribe:
     *   int32Values[0] : vehicle_ap_power_state_type
     *   int32Values[1] : additional parameter relevant for each state,
     *                    0 if not used.
     * Value format for IVehicle#set:
     *   int32Values[0] : vehicle_ap_power_state_set_type
     *   int32Values[1] : additional parameter relevant for each request. should be 0 if not used.
     *
     * @change_mode VEHICLE_PROP_CHANGE_MODE_ON_CHANGE
     * @access VEHICLE_PROP_ACCESS_READ_WRITE
     */
    AP_POWER_STATE = (
        0x0A00
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32_VEC
        | VehicleArea:GLOBAL),

    /**
     * Property to represent brightness of the display. Some cars have single
     * control for the brightness of all displays and this property is to share
     * change in that control.
     *
     * If this is writable, android side can set this value when user changes
     * display brightness from Settings. If this is read only, user may still
     * change display brightness from Settings, but that will not be reflected
     * to other displays.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    DISPLAY_BRIGHTNESS = (
        0x0A01
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:GLOBAL),

    /**
     * Property to report bootup reason for the current power on. This is a
     * static property that will not change for the whole duration until power
     * off. For example, even if user presses power on button after automatic
     * power on with door unlock, bootup reason must stay with
     * VehicleApPowerBootupReason#USER_UNLOCK.
     *
     * int32Values[0] must be VehicleApPowerBootupReason.
     *
     * @change_mode VehiclePropertyChangeMode:STATIC
     * @access VehiclePropertyAccess:READ
    */
    AP_POWER_BOOTUP_REASON = (
        0x0A02
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:GLOBAL),

    /**
     * Property to feed H/W input events to android
     *
     * int32Values[0] : action defined by VehicleHwKeyInputAction
     * int32Values[1] : key code, must use standard android key code
     * int32Values[2] : target display defined in VehicleDisplay. Events not
     *                  tied to specific display must be sent to
     *                  VehicleDisplay#MAIN.
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ
     * @config_flags
     */
    HW_KEY_INPUT = (
        0x0A10
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32_VEC
        | VehicleArea:GLOBAL),

    /**
     * Property to define instrument cluster information.
     * For VehicleInstrumentClusterType:EXTERNAL_DISPLAY:
     *  READ:
     *   int32Values[0] : The current screen mode index. Screen mode is defined
     *                    as a configuration in car service and represents
     *                    which area of screen is renderable.
     *   int32Values[1] : Android can render to instrument cluster (=1) or
     *                    not(=0). When this is 0, instrument cluster may be
     *                    rendering some information in the area allocated for
     *                    android and android side rendering is invisible.
     *  WRITE from android:
     *   int32Values[0] : Preferred mode for android side. Depending on the app
     *                    rendering to instrument cluster, preferred mode can
     *                    change. Instrument cluster still needs to send
     *                    event with new mode to trigger actual mode change.
     *   int32Values[1] : The current app context relevant for instrument
     *                    cluster. Use the same flag with
     *                    VehicleAudioContextFlag but this context represents
     *                    active apps, not active audio. Instrument cluster
     *                    side may change mode depending on the currently
     *                    active contexts.
     *  When system boots up, Android side will write {0, 0, 0, 0} when it is
     *  ready to render to instrument cluster. Before this message, rendering
     *  from android must not be visible in the cluster.
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     * @configArray 0:VehicleInstrumentClusterType 1:hw type
     */
    INSTRUMENT_CLUSTER_INFO = (
        0x0A20
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32_VEC
        | VehicleArea:GLOBAL),

    /**
     * Current date and time, encoded as Unix time.
     * This value denotes the number of seconds that have elapsed since
     * 1/1/1970.
     *
     * @change_mode VehiclePropertyChangeMode:ON_SET
     * @access VehiclePropertyAccess:READ_WRITE
     * @unit VehicleUnit:SECS
     */
    UNIX_TIME = (
        0x0A30
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT64
        | VehicleArea:GLOBAL),

    /**
     * Current time only.
     * Some vehicles may not keep track of date.  This property only affects
     * the current time, in seconds during the day.  Thus, the max value for
     * this parameter is 86,400 (24 * 60 * 60)
     *
     * @change_mode VehiclePropertyChangeMode:ON_SET
     * @access VehiclePropertyAccess:READ_WRITE
     * @unit VehicleUnit:SECS
     */
    CURRENT_TIME_IN_SECONDS = (
        0x0A31
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:GLOBAL),

    /**
     * Door position
     *
     * This is an integer in case a door may be set to a particular position.
     * Max value indicates fully open, min value (0) indicates fully closed.
     *
     * Some vehicles (minivans) can open the door electronically.  Hence, the
     * ability to write this property.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    DOOR_POS = (
        0x0B00
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:DOOR),

    /**
     * Door move
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    DOOR_MOVE = (
        0x0B01
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:DOOR),

    /**
     * Door lock
     *
     * 'true' indicates door is locked
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    DOOR_LOCK = (
        0x0B02
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:BOOLEAN
        | VehicleArea:DOOR),

    /**
     * Mirror Z Position
     *
     * Positive value indicates tilt upwards, negative value is downwards
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    MIRROR_Z_POS = (
        0x0B40
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:MIRROR),

    /**
     * Mirror Z Move
     *
     * Positive value indicates tilt upwards, negative value is downwards
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    MIRROR_Z_MOVE = (
        0x0B41
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:MIRROR),

    /**
     * Mirror Y Position
     *
     * Positive value indicate tilt right, negative value is left
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    MIRROR_Y_POS = (
        0x0B42
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:MIRROR),

    /**
     * Mirror Y Move
     *
     * Positive value indicate tilt right, negative value is left
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    MIRROR_Y_MOVE = (
        0x0B43
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:MIRROR),

    /**
     * Mirror Lock
     *
     * True indicates mirror positions are locked and not changeable
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    MIRROR_LOCK = (
        0x0B44
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:BOOLEAN
        | VehicleArea:GLOBAL),

    /**
     * Mirror Fold
     *
     * True indicates mirrors are folded
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    MIRROR_FOLD = (
        0x0B45
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:BOOLEAN
        | VehicleArea:GLOBAL),

    /**
     * Seat memory select
     *
     * This parameter selects the memory preset to use to select the seat
     * position. The minValue is always 0, and the maxValue determines the
     * number of seat positions available.
     *
     * For instance, if the driver's seat has 3 memory presets, the maxValue
     * will be 3. When the user wants to select a preset, the desired preset
     * number (1, 2, or 3) is set.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:WRITE
     */
    SEAT_MEMORY_SELECT = (
        0x0B80
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:SEAT),

    /**
     * Seat memory set
     *
     * This setting allows the user to save the current seat position settings
     * into the selected preset slot.  The maxValue for each seat position
     * shall match the maxValue for SEAT_MEMORY_SELECT.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:WRITE
     */
    SEAT_MEMORY_SET = (
        0x0B81
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:SEAT),

    /**
     * Seatbelt buckled
     *
     * True indicates belt is buckled.
     *
     * Write access indicates automatic seat buckling capabilities.  There are
     * no known cars at this time, but you never know...
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    SEAT_BELT_BUCKLED = (
        0x0B82
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:BOOLEAN
        | VehicleArea:SEAT),

    /**
     * Seatbelt height position
     *
     * Adjusts the shoulder belt anchor point.
     * Max value indicates highest position
     * Min value indicates lowest position
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    SEAT_BELT_HEIGHT_POS = (
        0x0B83
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:SEAT),

    /**
     * Seatbelt height move
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    SEAT_BELT_HEIGHT_MOVE = (
        0x0B84
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:SEAT),

    /**
     * Seat fore/aft position
     *
     * Sets the seat position forward (closer to steering wheel) and backwards.
     * Max value indicates closest to wheel, min value indicates most rearward
     * position.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    SEAT_FORE_AFT_POS = (
        0x0B85
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:SEAT),

    /**
     * Seat fore/aft move
     *
     * Moves the seat position forward and aft.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    SEAT_FORE_AFT_MOVE = (
        0x0B86
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:SEAT),

    /**
     * Seat backrest angle 1 position
     *
     * Backrest angle 1 is the actuator closest to the bottom of the seat.
     * Max value indicates angling forward towards the steering wheel.
     * Min value indicates full recline.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    SEAT_BACKREST_ANGLE_1_POS = (
        0x0B87
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:SEAT),

    /**
     * Seat backrest angle 1 move
     *
     * Moves the backrest forward or recline.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    SEAT_BACKREST_ANGLE_1_MOVE = (
        0x0B88
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:SEAT),

    /**
     * Seat backrest angle 2 position
     *
     * Backrest angle 2 is the next actuator up from the bottom of the seat.
     * Max value indicates angling forward towards the steering wheel.
     * Min value indicates full recline.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    SEAT_BACKREST_ANGLE_2_POS = (
        0x0B89
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:SEAT),

    /**
     * Seat backrest angle 2 move
     *
     * Moves the backrest forward or recline.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    SEAT_BACKREST_ANGLE_2_MOVE = (
        0x0B8A
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:SEAT),

    /**
     * Seat height position
     *
     * Sets the seat height.
     * Max value indicates highest position.
     * Min value indicates lowest position.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    SEAT_HEIGHT_POS = (
        0x0B8B
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:SEAT),

    /**
     * Seat height move
     *
     * Moves the seat height.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    SEAT_HEIGHT_MOVE = (
        0x0B8C
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:SEAT),

    /**
     * Seat depth position
     *
     * Sets the seat depth, distance from back rest to front edge of seat.
     * Max value indicates longest depth position.
     * Min value indicates shortest position.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    SEAT_DEPTH_POS = (
        0x0B8D
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:SEAT),

    /**
     * Seat depth move
     *
     * Adjusts the seat depth.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    SEAT_DEPTH_MOVE = (
        0x0B8E
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:SEAT),

    /**
     * Seat tilt position
     *
     * Sets the seat tilt.
     * Max value indicates front edge of seat higher than back edge.
     * Min value indicates front edge of seat lower than back edge.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    SEAT_TILT_POS = (
        0x0B8F
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:SEAT),

    /**
     * Seat tilt move
     *
     * Tilts the seat.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    SEAT_TILT_MOVE = (
        0x0B90
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:SEAT),

    /**
     * Lumber fore/aft position
     *
     * Pushes the lumbar support forward and backwards
     * Max value indicates most forward position.
     * Min value indicates most rearward position.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    SEAT_LUMBAR_FORE_AFT_POS = (
        0x0B91
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:SEAT),

    /**
     * Lumbar fore/aft move
     *
     * Adjusts the lumbar support.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    SEAT_LUMBAR_FORE_AFT_MOVE = (
        0x0B92
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:SEAT),

    /**
     * Lumbar side support position
     *
     * Sets the amount of lateral lumbar support.
     * Max value indicates widest lumbar setting (i.e. least support)
     * Min value indicates thinnest lumbar setting.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    SEAT_LUMBAR_SIDE_SUPPORT_POS = (
        0x0B93
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:SEAT),

    /**
     * Lumbar side support move
     *
     * Adjusts the amount of lateral lumbar support.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    SEAT_LUMBAR_SIDE_SUPPORT_MOVE = (
        0x0B94
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:SEAT),

    /**
     * Headrest height position
     *
     * Sets the headrest height.
     * Max value indicates tallest setting.
     * Min value indicates shortest setting.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    SEAT_HEADREST_HEIGHT_POS = (
        0x0B95
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:GLOBAL),

    /**
     * Headrest height move
     *
     * Moves the headrest up and down.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    SEAT_HEADREST_HEIGHT_MOVE = (
        0x0B96
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:SEAT),

    /**
     * Headrest angle position
     *
     * Sets the angle of the headrest.
     * Max value indicates most upright angle.
     * Min value indicates shallowest headrest angle.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    SEAT_HEADREST_ANGLE_POS = (
        0x0B97
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:SEAT),

    /**
     * Headrest angle move
     *
     * Adjusts the angle of the headrest
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    SEAT_HEADREST_ANGLE_MOVE = (
        0x0B98
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:SEAT),

    /**
     * Headrest fore/aft position
     *
     * Adjusts the headrest forwards and backwards.
     * Max value indicates position closest to front of car.
     * Min value indicates position closest to rear of car.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    SEAT_HEADREST_FORE_AFT_POS = (
        0x0B99
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:SEAT),

    /**
     * Headrest fore/aft move
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    SEAT_HEADREST_FORE_AFT_MOVE = (
        0x0B9A
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:SEAT),

    /**
     * Window Position
     *
     * Max = window up / closed
     * Min = window down / open
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    WINDOW_POS = (
        0x0BC0
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:GLOBAL),

    /**
     * Window Move
     *
     * Max = window up / closed
     * Min = window down / open
     * Magnitude denotes relative speed.  I.e. +2 is faster than +1 in raising
     * the window.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    WINDOW_MOVE = (
        0x0BC1
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:GLOBAL),

    /**
     * Window Vent Position
     *
     * This feature is used to control the vent feature on a sunroof.
     *
     * Max = vent open
     * Min = vent closed
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    WINDOW_VENT_POS = (
        0x0BC2
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:GLOBAL),

    /**
     * Window Vent Move
     *
     * This feature is used to control the vent feature on a sunroof.
     *
     * Max = vent open
     * Min = vent closed
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    WINDOW_VENT_MOVE = (
        0x0BC3
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:GLOBAL),

    /**
     * Window Lock
     *
     * True indicates windows are locked and can't be moved.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    WINDOW_LOCK = (
        0x0BC4
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:BOOLEAN
        | VehicleArea:GLOBAL),


    /**
     * Vehicle Maps Service (VMS) message
     *
     * This property uses COMPLEX data to communicate vms messages.
     *
     * Its contents are to be interpreted as follows:
     * the indices defined in VmsMessageIntegerValuesIndex are to be used to
     * read from int32Values;
     * bytes is a serialized VMS message as defined in the vms protocol
     * which is opaque to the framework;
     *
     * IVehicle#get must always return StatusCode::NOT_AVAILABLE.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     *
     * @since o.mr1
     */
    VEHICLE_MAP_SERVICE = (
        0x0C00
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:COMPLEX
        | VehicleArea:GLOBAL),

    /**
     * OBD2 Live Sensor Data
     *
     * Reports a snapshot of the current (live) values of the OBD2 sensors available.
     *
     * The configArray is set as follows:
     *   configArray[0] = number of vendor-specific integer-valued sensors
     *   configArray[1] = number of vendor-specific float-valued sensors
     *
     * The values of this property are to be interpreted as in the following example.
     * Considering a configArray = {2,3}
     * int32Values must be a vector containing Obd2IntegerSensorIndex.LAST_SYSTEM_INDEX + 2
     * elements (that is, 33 elements);
     * floatValues must be a vector containing Obd2FloatSensorIndex.LAST_SYSTEM_INDEX + 3
     * elements (that is, 73 elements);
     *
     * It is possible for each frame to contain a different subset of sensor values, both system
     * provided sensors, and vendor-specific ones. In order to support that, the bytes element
     * of the property value is used as a bitmask,.
     *
     * bytes must have a sufficient number of bytes to represent the total number of possible
     * sensors (in this case, 14 bytes to represent 106 possible values); it is to be read as
     * a contiguous bitmask such that each bit indicates the presence or absence of a sensor
     * from the frame, starting with as many bits as the size of int32Values, immediately
     * followed by as many bits as the size of floatValues.
     *
     * For example, should bytes[0] = 0x4C (0b01001100) it would mean that:
     *   int32Values[0 and 1] are not valid sensor values
     *   int32Values[2 and 3] are valid sensor values
     *   int32Values[4 and 5] are not valid sensor values
     *   int32Values[6] is a valid sensor value
     *   int32Values[7] is not a valid sensor value
     * Should bytes[5] = 0x61 (0b01100001) it would mean that:
     *   int32Values[32] is a valid sensor value
     *   floatValues[0 thru 3] are not valid sensor values
     *   floatValues[4 and 5] are valid sensor values
     *   floatValues[6] is not a valid sensor value
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ
     *
     * @since o.mr1
     */
    OBD2_LIVE_FRAME = (
      0x0D00
      | VehiclePropertyGroup:SYSTEM
      | VehiclePropertyType:COMPLEX
      | VehicleArea:GLOBAL),

    /**
     * OBD2 Freeze Frame Sensor Data
     *
     * Reports a snapshot of the value of the OBD2 sensors available at the time that a fault
     * occurred and was detected.
     *
     * A configArray must be provided with the same meaning as defined for OBD2_LIVE_FRAME.
     *
     * The values of this property are to be interpreted in a similar fashion as those for
     * OBD2_LIVE_FRAME, with the exception that the stringValue field may contain a non-empty
     * diagnostic troubleshooting code (DTC).
     *
     * A IVehicle#get request of this property must provide a value for int64Values[0].
     * This will be interpreted as the timestamp of the freeze frame to retrieve. A list of
     * timestamps can be obtained by a IVehicle#get of OBD2_FREEZE_FRAME_INFO.
     *
     * Should no freeze frame be available at the given timestamp, a response of NOT_AVAILABLE
     * must be returned by the implementation. Because vehicles may have limited storage for
     * freeze frames, it is possible for a frame request to respond with NOT_AVAILABLE even if
     * the associated timestamp has been recently obtained via OBD2_FREEZE_FRAME_INFO.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ
     *
     * @since o.mr1
     */
    OBD2_FREEZE_FRAME = (
      0x0D01
      | VehiclePropertyGroup:SYSTEM
      | VehiclePropertyType:COMPLEX
      | VehicleArea:GLOBAL),

    /**
     * OBD2 Freeze Frame Information
     *
     * This property describes the current freeze frames stored in vehicle
     * memory and available for retrieval via OBD2_FREEZE_FRAME.
     *
     * The values are to be interpreted as follows:
     * each element of int64Values must be the timestamp at which a a fault code
     * has been detected and the corresponding freeze frame stored, and each
     * such element can be used as the key to OBD2_FREEZE_FRAME to retrieve
     * the corresponding freeze frame.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ
     *
     * @since o.mr1
     */
    OBD2_FREEZE_FRAME_INFO = (
      0x0D02
      | VehiclePropertyGroup:SYSTEM
      | VehiclePropertyType:COMPLEX
      | VehicleArea:GLOBAL),

    /**
     * OBD2 Freeze Frame Clear
     *
     * This property allows deletion of any of the freeze frames stored in
     * vehicle memory, as described by OBD2_FREEZE_FRAME_INFO.
     *
     * The configArray is set as follows:
     *  configArray[0] = 1 if the implementation is able to clear individual freeze frames
     *                   by timestamp, 0 otherwise
     *
     * IVehicle#set of this property is to be interpreted as follows:
     *   if int64Values contains no elements, then all frames stored must be cleared;
     *   if int64Values contains one or more elements, then frames at the timestamps
     *   stored in int64Values must be cleared, and the others not cleared. Should the
     *   vehicle not support selective clearing of freeze frames, this latter mode must
     *   return NOT_AVAILABLE.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:WRITE
     *
     * @since o.mr1
     */
    OBD2_FREEZE_FRAME_CLEAR = (
      0x0D03
      | VehiclePropertyGroup:SYSTEM
      | VehiclePropertyType:COMPLEX
      | VehicleArea:GLOBAL),
};

/**
 * Bit flags for fan direction
 */
enum VehicleHvacFanDirection : int32_t {
    FACE = 0x1,
    FLOOR = 0x2,
    FACE_AND_FLOOR = 0x3,
    DEFROST = 0x4,
    DEFROST_AND_FLOOR = 0x5,
};

/**
 * Constants relevant to radio.
 */
enum VehicleRadioConstants : int32_t {
    /** Minimum value for the radio preset */
    VEHICLE_RADIO_PRESET_MIN_VALUE = 1,
};

enum VehicleAudioFocusRequest : int32_t {
    REQUEST_GAIN = 0x1,
    REQUEST_GAIN_TRANSIENT = 0x2,
    REQUEST_GAIN_TRANSIENT_MAY_DUCK = 0x3,
    /**
     * This is for the case where android side plays sound like UI feedback
     * and car side does not need to duck existing playback as long as
     * requested stream is available.
     */
    REQUEST_GAIN_TRANSIENT_NO_DUCK = 0x4,
    REQUEST_RELEASE = 0x5,
};

enum VehicleAudioFocusState : int32_t {
    /**
     * Android side has permanent focus and can play allowed streams.
     */
    STATE_GAIN = 0x1,

    /**
     * Android side has transient focus and can play allowed streams.
     */
    STATE_GAIN_TRANSIENT = 0x2,

    /**
     * Car audio module is playing guidance kind of sound outside Android.
     * Android side can still play through allowed streams with ducking.
     */
    STATE_LOSS_TRANSIENT_CAN_DUCK = 0x3,

    /**
     * Car audio module is playing transient sound outside Android. Android side
     * must stop playing any sounds.
     */
    STATE_LOSS_TRANSIENT = 0x4,

    /**
     * Android side has lost focus and cannot play any sound.
     */
    STATE_LOSS = 0x5,

    /**
     * car audio module is playing safety critical sound, and Android side cannot
     * request focus until the current state is finished. car audio module
     * restore it to the previous state when it can allow Android to play.
     */
    STATE_LOSS_TRANSIENT_EXLCUSIVE = 0x6,
};

/**
 * Flags to represent multiple streams by combining these.
 */
enum VehicleAudioStreamFlag : int32_t {
    STREAM0_FLAG = (0x1 << 0),
    STREAM1_FLAG = (0x1 << 1),
    STREAM2_FLAG = (0x1 << 2),
};

/**
 * Represents stream number (always 0 to N -1 where N is max number of streams).
 * Can be used for audio related property expecting one stream.
 */
enum VehicleAudioStream : int32_t {
    STREAM0 = 0,
    STREAM1 = 1,
};

/**
 * Flag to represent external focus state (outside Android).
 */
enum VehicleAudioExtFocusFlag : int32_t {
    /**
     * No external focus holder.
     */
    NONE_FLAG = 0x0,

    /**
     * Car side (outside Android) has component holding GAIN kind of focus state.
     */
    PERMANENT_FLAG = 0x1,

    /**
     * Car side (outside Android) has component holding GAIN_TRANSIENT kind of
     * focus state.
     */
    TRANSIENT_FLAG = 0x2,

    /**
     * Car side is expected to play something while focus is held by Android side.
     * One example can be radio attached in car side. But Android's radio app
     * still must have focus, and Android side must be in GAIN state, but
     * media stream will not be allocated to Android side and car side can play
     * radio any time while this flag is active.
     */
    PLAY_ONLY_FLAG = 0x4,

    /**
     * Car side must mute any media including radio. This can be used with any
     * focus request including GAIN* and RELEASE.
     */
    MUTE_MEDIA_FLAG = 0x8,
};

/**
 * Index in int32Values for VehicleProperty#AUDIO_FOCUS property.
 */
enum VehicleAudioFocusIndex : int32_t {
    FOCUS = 0,
    STREAMS = 1,
    EXTERNAL_FOCUS_STATE = 2,
    AUDIO_CONTEXTS = 3,
};

/**
 * Flags to tell the current audio context.
 */
enum VehicleAudioContextFlag : int32_t {
    /** Music playback is currently active. */
    MUSIC_FLAG = 0x1,

    /** Navigation is currently running. */
    NAVIGATION_FLAG = 0x2,

    /** Voice command session is currently running. */
    VOICE_COMMAND_FLAG = 0x4,

    /** Voice call is currently active. */
    CALL_FLAG = 0x8,

    /**
     * Alarm is active.
     * This must be only used in VehicleProperty#AUDIO_ROUTING_POLICY.
     */
    ALARM_FLAG = 0x10,

    /**
     * Notification sound is active.
     * This must be only used in VehicleProperty#AUDIO_ROUTING_POLICY.
     */
    NOTIFICATION_FLAG = 0x20,

    /**
     * Context unknown. Only used for VehicleProperty#AUDIO_ROUTING_POLICY to
     * represent default stream for unknown contents.
     */
    UNKNOWN_FLAG = 0x40,

    /** Safety alert / warning is played. */
    SAFETY_ALERT_FLAG = 0x80,

    /** CD / DVD kind of audio is played */
    CD_ROM_FLAG = 0x100,

    /** Aux audio input is played */
    AUX_AUDIO_FLAG = 0x200,

    /** system sound like UI feedback */
    SYSTEM_SOUND_FLAG = 0x400,

    /** Radio is played */
    RADIO_FLAG = 0x800,

    /** Ext source is played. This is for tagging generic ext sources. */
    EXT_SOURCE_FLAG = 0x1000,

    /** The phone ring tone is played */
    RINGTONE_FLAG = 0x2000
};

/**
 * flags to represent capability of audio volume property.
 * used in configArray[1] of VehiclePropConfig.
 */
enum VehicleAudioVolumeCapabilityFlag : int32_t {
    /**
     * External audio module or vehicle hal has persistent storage to keep the
     * volume level. When this is set, the audio volume level for each context
     * will be retrieved from the property when the system starts up.
     * And external audio module is also expected to adjust volume automatically
     * whenever there is an audio context change.
     * When this flag is not set, android side will assume that there is no
     * persistent storage and the value stored in the android side will be used to
     * initialize the volume level, and android side will set volume level
     * of each physical stream whenever there is an audio context change.
     */
    PERSISTENT_STORAGE = 0x1,

    /**
     * [DEPRECATED]
     * When this flag is set, the H/W can support only single master volume for
     * all streams. There is no way to set volume level differently for each stream
     * or context.
     */
    MASTER_VOLUME_ONLY = 0x2,
};

/**
 * enum to represent audio volume state.
 */
enum VehicleAudioVolumeState : int32_t {
    STATE_OK = 0,

    /**
     * Audio volume has reached volume limit set in
     * VehicleProperty#AUDIO_VOLUME_LIMIT and user's request to increase volume
     * further is not allowed.
     */
    STATE_LIMIT_REACHED = 1,
};

/**
 * Index in int32Values for VehicleProperty#AUDIO_VOLUME property.
 */
enum VehicleAudioVolumeIndex : int32_t {
    STREAM = 0,
    VOLUME = 1,
    STATE = 2,
};

/**
 * Index in int32Values for VehicleProperty#AUDIO_VOLUME_LIMIT property.
 */
enum VehicleAudioVolumeLimitIndex : int32_t {
    STREAM = 0,
    MAX_VOLUME = 1,
};

/**
 * Index in int32Values for VehicleProperty#AUDIO_ROUTING_POLICY property.
 */
enum VehicleAudioRoutingPolicyIndex : int32_t {
    STREAM = 0,
    CONTEXTS = 1,
};

/**
 * Flag to be used in VehiclePropConfig#configFlags for
 * VehicleProperty#AUDIO_HW_VARIANT.
 */
enum VehicleAudioHwVariantConfigFlag : int32_t {
  /**
   * Flag to tell that radio is internal to android and radio must
   * be treated like other android stream like media.
   * When this flag is not set or AUDIO_HW_VARIANT does not exist,
   * radio is treated as external module. This may affect audio focus
   * handling as well.
   */
  INTERNAL_RADIO_FLAG = 0x1,
};

enum VehicleApPowerStateConfigFlag : int32_t /* NOTE: type is guessed */ {
    /**
     * AP can enter deep sleep state. If not set, AP will always shutdown from
     * VehicleApPowerState#SHUTDOWN_PREPARE power state.
     */
    ENABLE_DEEP_SLEEP_FLAG = 0x1,

    /**
     * The power controller can power on AP from off state after timeout
     * specified in VehicleApPowerSet VEHICLE_AP_POWER_SET_SHUTDOWN_READY message.
     */
    CONFIG_SUPPORT_TIMER_POWER_ON_FLAG = 0x2,
};

enum VehicleApPowerState : int32_t /* NOTE: type is guessed */ {
    /** vehicle HAL will never publish this state to AP */
    OFF = 0,

    /** vehicle HAL will never publish this state to AP */
    DEEP_SLEEP = 1,

    /** AP is on but display must be off. */
    ON_DISP_OFF = 2,

    /** AP is on with display on. This state allows full user interaction. */
    ON_FULL = 3,

    /**
     * The power controller has requested AP to shutdown. AP can either enter
     * sleep state or start full shutdown. AP can also request postponing
     * shutdown by sending VehicleApPowerSetState#SHUTDOWN_POSTPONE message. The
     * power controller must change power state to this state to shutdown
     * system.
     *
     * int32Values[1] : one of enum_vehicle_ap_power_state_shutdown_param_type
     */
    SHUTDOWN_PREPARE = 4,
};

enum VehicleApPowerStateShutdownParam : int32_t {
    /** AP must shutdown immediately. Postponing is not allowed. */
    SHUTDOWN_IMMEDIATELY = 1,

    /** AP can enter deep sleep instead of shutting down completely. */
    CAN_SLEEP = 2,

    /** AP can only shutdown with postponing allowed. */
    SHUTDOWN_ONLY = 3,
};

enum VehicleApPowerSetState : int32_t /* NOTE: type is guessed */ {
    /**
     * AP has finished boot up, and can start shutdown if requested by power
     * controller.
     */
    BOOT_COMPLETE = 0x1,

    /**
     * AP is entering deep sleep state. How this state is implemented may vary
     * depending on each H/W, but AP's power must be kept in this state.
     */
    DEEP_SLEEP_ENTRY = 0x2,

    /**
     * AP is exiting from deep sleep state, and is in
     * VehicleApPowerState#SHUTDOWN_PREPARE state.
     * The power controller may change state to other ON states based on the
     * current state.
     */
    DEEP_SLEEP_EXIT = 0x3,

    /**
     * int32Values[1]: Time to postpone shutdown in ms. Maximum value can be
     *                 5000 ms.
     *                 If AP needs more time, it will send another POSTPONE
     *                 message before the previous one expires.
     */
    SHUTDOWN_POSTPONE = 0x4,

    /**
     * AP is starting shutting down. When system completes shutdown, everything
     * will stop in AP as kernel will stop all other contexts. It is
     * responsibility of vehicle HAL or lower level to synchronize that state
     * with external power controller. As an example, some kind of ping
     * with timeout in power controller can be a solution.
     *
     * int32Values[1]: Time to turn on AP in secs. Power controller may turn on
     *                 AP after specified time so that AP can run tasks like
     *                 update. If it is set to 0, there is no wake up, and power
     *                 controller may not necessarily support wake-up. If power
     *                 controller turns on AP due to timer, it must start with
     *                 VehicleApPowerState#ON_DISP_OFF state, and after
     *                 receiving VehicleApPowerSetState#BOOT_COMPLETE, it shall
     *                 do state transition to
     *                 VehicleApPowerState#SHUTDOWN_PREPARE.
     */
    SHUTDOWN_START = 0x5,

    /**
     * User has requested to turn off headunit's display, which is detected in
     * android side.
     * The power controller may change the power state to
     * VehicleApPowerState#ON_DISP_OFF.
     */
    DISPLAY_OFF = 0x6,

    /**
     * User has requested to turn on headunit's display, most probably from power
     * key input which is attached to headunit. The power controller may change
     * the power state to VehicleApPowerState#ON_FULL.
     */
    DISPLAY_ON = 0x7,
};

/**
 * Index in int32Values for VehicleProperty#AP_POWER_STATE property.
 */
enum VehicleApPowerStateIndex : int32_t {
    STATE = 0,
    ADDITIONAL = 1,
};

/**
 * Enum to represent bootup reason.
 */
enum VehicleApPowerBootupReason : int32_t {
    /**
     * Power on due to user's pressing of power key or rotating of ignition
     * switch.
     */
    USER_POWER_ON = 0,

    /**
     * Automatic power on triggered by door unlock or any other kind of automatic
     * user detection.
     */
    USER_UNLOCK = 1,

    /**
     * Automatic power on triggered by timer. This only happens when AP has asked
     * wake-up after
     * certain time through time specified in
     * VehicleApPowerSetState#SHUTDOWN_START.
     */
    TIMER = 2,
};

enum VehicleHwKeyInputAction : int32_t {
    /** Key down */
    ACTION_DOWN = 0,

    /** Key up */
    ACTION_UP = 1,
};

enum VehicleDisplay : int32_t {
    /** center console */
    MAIN = 0,

    INSTRUMENT_CLUSTER = 1,
};

/**
 * Represents instrument cluster type available in system
 */
enum VehicleInstrumentClusterType : int32_t {
  /** Android has no access to instument cluster */
  NONE = 0,

  /**
   * Instrument cluster can communicate through vehicle hal with additional
   * properties to exchange meta-data
   */
  HAL_INTERFACE = 1,

  /**
   * Instrument cluster is external display where android can render contents
   */
  EXTERNAL_DISPLAY = 2,
};

/**
 * Units used for int or float type with no attached enum types.
 */
enum VehicleUnit : int32_t {
    SHOULD_NOT_USE = 0x000,

    METER_PER_SEC  = 0x01,
    RPM            = 0x02,
    HERTZ          = 0x03,
    PERCENTILE     = 0x10,
    MILLIMETER     = 0x20,
    METER          = 0x21,
    KILOMETER      = 0x23,
    CELSIUS        = 0x30,
    FAHRENHEIT     = 0x31,
    KELVIN         = 0x32,
    MILLILITER     = 0x40,
    NANO_SECS      = 0x50,
    SECS           = 0x53,
    YEAR           = 0x59,
};

  /**
   * This describes how value of property can change.
   */
enum VehiclePropertyChangeMode : int32_t {
  /**
   * Property of this type must never be changed. Subscription is not supported
   * for these properties.
   */
  STATIC = 0x00,

  /**
   * Property of this type must be reported when there is a change.
   * IVehicle#get call must return the current value.
   * Set operation for this property is assumed to be asynchronous. When the
   * property is read (using IVehicle#get) after IVehicle#set, it may still
   * return old value until underlying H/W backing this property has actually
   * changed the state. Once state is changed, the property must dispatch
   * changed value as event.
   */
  ON_CHANGE = 0x01,

  /**
   * Property of this type change continuously and requires fixed rate of
   * sampling to retrieve the data.
   */
  CONTINUOUS = 0x02,

  /**
   * Property of this type may be polled to get the current value.
   */
  POLL = 0x03,

  /**
   * This is for property where change event must be sent only when the
   * value is set from external component. Normal value change must not trigger
   * event. For example, clock property can send change event only when it is
   * set, outside android, for case like user setting time or time getting
   * update. There is no need to send it per every value change.
   */
  ON_SET = 0x04,
};

/**
 * Property config defines the capabilities of it. User of the API
 * must first get the property config to understand the output from get()
 * commands and also to ensure that set() or events commands are in sync with
 * the expected output.
 */
enum VehiclePropertyAccess : int32_t {
    NONE = 0x00,

    READ = 0x01,
    WRITE = 0x02,
    READ_WRITE = 0x03,
};

/**
 * Car states.
 *
 * The driving states determine what features of the UI will be accessible.
 */
enum VehicleDrivingStatus : int32_t {
    UNRESTRICTED = 0x00,
    NO_VIDEO = 0x01,
    NO_KEYBOARD_INPUT = 0x02,
    NO_VOICE_INPUT = 0x04,
    NO_CONFIG = 0x08,
    LIMIT_MESSAGE_LEN = 0x10,
};

/**
 * Various gears which can be selected by user and chosen in system.
 */
enum VehicleGear: int32_t {
    GEAR_NEUTRAL = 0x0001,
    GEAR_REVERSE = 0x0002,
    GEAR_PARK = 0x0004,
    GEAR_DRIVE = 0x0008,
    GEAR_LOW = 0x0010,
    GEAR_1 = 0x0010,
    GEAR_2 = 0x0020,
    GEAR_3 = 0x0040,
    GEAR_4 = 0x0080,
    GEAR_5 = 0x0100,
    GEAR_6 = 0x0200,
    GEAR_7 = 0x0400,
    GEAR_8 = 0x0800,
    GEAR_9 = 0x1000,
};

/**
 * Various zones in the car.
 *
 * Zones are used for Air Conditioning purposes and divide the car into physical
 * area zones.
 */
enum VehicleAreaZone : int32_t {
  ROW_1_LEFT = 0x00000001,
  ROW_1_CENTER = 0x00000002,
  ROW_1_RIGHT = 0x00000004,
  ROW_1 = 0x00000008,
  ROW_2_LEFT = 0x00000010,
  ROW_2_CENTER = 0x00000020,
  ROW_2_RIGHT = 0x00000040,
  ROW_2 = 0x00000080,
  ROW_3_LEFT = 0x00000100,
  ROW_3_CENTER = 0x00000200,
  ROW_3_RIGHT = 0x00000400,
  ROW_3 = 0x00000800,
  ROW_4_LEFT = 0x00001000,
  ROW_4_CENTER = 0x00002000,
  ROW_4_RIGHT = 0x00004000,
  ROW_4 = 0x00008000,
  WHOLE_CABIN = 0x80000000,
};

/**
 * Various Seats in the car.
 */
enum VehicleAreaSeat : int32_t {
    ROW_1_LEFT   = 0x0001,
    ROW_1_CENTER = 0x0002,
    ROW_1_RIGHT  = 0x0004,
    ROW_2_LEFT   = 0x0010,
    ROW_2_CENTER = 0x0020,
    ROW_2_RIGHT  = 0x0040,
    ROW_3_LEFT   = 0x0100,
    ROW_3_CENTER = 0x0200,
    ROW_3_RIGHT  = 0x0400
};

/**
 * Various windshields/windows in the car.
 */
enum VehicleAreaWindow : int32_t {
    FRONT_WINDSHIELD = 0x0001,
    REAR_WINDSHIELD = 0x0002,
    ROOF_TOP = 0x0004,
    ROW_1_LEFT = 0x0010,
    ROW_1_RIGHT = 0x0020,
    ROW_2_LEFT = 0x0100,
    ROW_2_RIGHT = 0x0200,
    ROW_3_LEFT = 0x1000,
    ROW_3_RIGHT = 0x2000,
};

enum VehicleAreaDoor : int32_t {
    ROW_1_LEFT = 0x00000001,
    ROW_1_RIGHT = 0x00000004,
    ROW_2_LEFT = 0x00000010,
    ROW_2_RIGHT = 0x00000040,
    ROW_3_LEFT = 0x00000100,
    ROW_3_RIGHT = 0x00000400,
    HOOD = 0x10000000,
    REAR = 0x20000000,
};

enum VehicleAreaMirror : int32_t {
    DRIVER_LEFT = 0x00000001,
    DRIVER_RIGHT = 0x00000002,
    DRIVER_CENTER = 0x00000004,
};

enum VehicleTurnSignal : int32_t {
    NONE = 0x00,
    RIGHT = 0x01,
    LEFT = 0x02,
    EMERGENCY = 0x04,
};

struct VehicleAreaConfig {
    /**
     * Area id is ignored for VehiclePropertyGroup:GLOBAL properties.
     */
    int32_t areaId;

    int32_t minInt32Value;
    int32_t maxInt32Value;

    int64_t minInt64Value;
    int64_t maxInt64Value;

    float minFloatValue;
    float maxFloatValue;
};

struct VehiclePropConfig {
    /** Property identifier */
    int32_t prop;

    /**
     * Defines if the property is read or write or both.
     */
    VehiclePropertyAccess access;

    /**
     * Defines the change mode of the property.
     */
    VehiclePropertyChangeMode changeMode;

    /**
     * Some of the properties may have associated areas (for example, some hvac
     * properties are associated with VehicleAreaZone), in these
     * cases the config may contain an ORed value for the associated areas.
     */
    int32_t supportedAreas;

    /**
     * Contains per-area configuration.
     */
    vec<VehicleAreaConfig> areaConfigs;

    /**
     * Configuration flags for this property.
     *
     * For example, it may store the number of presets that are stored by the
     * radio module.
     */
    int32_t configFlags;

    /** Contains additional configuration parameters */
    vec<int32_t> configArray;

    /**
     * Some properties may require additional information passed over this
     * string. Most properties do not need to set this.
     */
    string configString;

    /**
     * Min sample rate in Hz.
     * Must be defined for VehiclePropertyChangeMode::CONTINUOUS
     */
    float minSampleRate;

    /**
     * Must be defined for VehiclePropertyChangeMode::CONTINUOUS
     * Max sample rate in Hz.
     */
    float maxSampleRate;
};

/**
 * Encapsulates the property name and the associated value. It
 * is used across various API calls to set values, get values or to register for
 * events.
 */
struct VehiclePropValue {
    /** Property identifier */
    int32_t prop;

    /** Time is elapsed nanoseconds since boot */
    int64_t timestamp;

    /**
     * Area type(s) for non-global property it must be one of the value from
     * VehicleArea* enums or 0 for global properties.
     */
    int32_t areaId;

    /**
     * Contains value for a single property. Depending on property data type of
     * this property (VehiclePropetyType) one field of this structure must be filled in.
     */
    struct RawValue {
        /**
         * This is used for properties of types VehiclePropertyType#INT
         * and VehiclePropertyType#INT_VEC
         */
        vec<int32_t> int32Values;

        /**
         * This is used for properties of types VehiclePropertyType#FLOAT
         * and VehiclePropertyType#FLOAT_VEC
         */
        vec<float> floatValues;

        /** This is used for properties of type VehiclePropertyType#INT64 */
        vec<int64_t> int64Values;

        /** This is used for properties of type VehiclePropertyType#BYTES */
        vec<uint8_t> bytes;

        /** This is used for properties of type VehiclePropertyType#STRING */
        string stringValue;
    };

    RawValue value;
};

enum VehicleIgnitionState : int32_t {
    UNDEFINED = 0,

    /** Steering wheel is locked */
    LOCK = 1,

     /**
      * Steering wheel is not locked, engine and all accessories are OFF. If
      * car can be in LOCK and OFF state at the same time than HAL must report
      * LOCK state.
      */
    OFF,

    /**
     * Typically in this state accessories become available (e.g. radio).
     * Instrument cluster and engine are turned off
     */
    ACC,

    /**
     * Ignition is in state ON. Accessories and instrument cluster available,
     * engine might be running or ready to be started.
     */
    ON,

    /** Typically in this state engine is starting (cranking). */
    START
};


/**
 * Represent the operation where the current error has happened.
 */
enum VehiclePropertyOperation : int32_t {
    /**
     * Generic error to this property which is not tied to any operation.
     */
    GENERIC = 0,

    /**
     * Error happened while handling property set.
     */
    SET = 1,

    /**
     * Error happened while handling property get.
     */
    GET = 2,

    /**
     * Error happened while handling property subscription.
     */
    SUBSCRIBE = 3,
};


enum SubscribeFlags : int32_t {
    UNDEFINED = 0x0,

    /**
     * Subscribe to event that was originated in vehicle HAL
     * (most likely this event came from the vehicle itself).
     */
    HAL_EVENT = 0x1,

    /**
     * Use this flag to subscribe on events when IVehicle#set(...) was called by
     * vehicle HAL's client (e.g. Car Service).
     */
    SET_CALL = 0x2,

    DEFAULT = HAL_EVENT,
};

/**
 * Encapsulates information about subscription to vehicle property events.
 */
struct SubscribeOptions {
    /** Property to subscribe */
    int32_t propId;

    /**
     * Area ids - this must be a bit mask of areas to subscribe or 0 to subscribe
     * to all areas.
     */
    int32_t vehicleAreas;

    /**
     * Sample rate in Hz.
     *
     * Must be provided for properties with
     * VehiclePropertyChangeMode::CONTINUOUS. The value must be within
     * VehiclePropConfig#minSamplingRate .. VehiclePropConfig#maxSamplingRate
     * for a given property.
     * This value indicates how many updates per second client wants to receive.
     */
    float sampleRate;

    /** Flags that indicate what kind of events listen to. */
    SubscribeFlags flags;
};

/** Error codes used in vehicle HAL interface. */
enum StatusCode : int32_t {
    OK = 0,

    /** Try again. */
    TRY_AGAIN = 1,

    /** Invalid argument provided. */
    INVALID_ARG = 2,

    /**
     * This code must be returned when device that associated with the vehicle
     * property is not available. For example, when client tries to set HVAC
     * temperature when the whole HVAC unit is turned OFF.
     */
    NOT_AVAILABLE = 3,

    /** Access denied */
    ACCESS_DENIED = 4,

    /** Something unexpected has happened in Vehicle HAL */
    INTERNAL_ERROR = 5,
};

enum Wheel : int32_t {
    UNKNOWN = 0x0,

    LEFT_FRONT = 0x1,
    RIGHT_FRONT = 0x2,
    LEFT_REAR = 0x4,
    RIGHT_REAR = 0x8,
};

/**
 * The status of the vehicle's fuel system.
 * These values come from the SAE J1979 standard.
 */
enum Obd2FuelSystemStatus : int32_t {
    OPEN_INSUFFICIENT_ENGINE_TEMPERATURE = 1,
    CLOSED_LOOP = 2,
    OPEN_ENGINE_LOAD_OR_DECELERATION = 4,
    OPEN_SYSTEM_FAILURE = 8,
    CLOSED_LOOP_BUT_FEEDBACK_FAULT = 16,
};

/** Defines which ignition monitors are available to be read. */
enum Obd2IgnitionMonitorKind : int32_t {
    SPARK = 0,
    COMPRESSION = 1,
};

/**
 * Ignition monitors common to both SPARK and COMPRESSION.
 * These values come from the SAE J1979 standard.
 */
enum Obd2CommonIgnitionMonitors : int32_t {
    COMPONENTS_AVAILABLE = 0x1 << 0,
    COMPONENTS_INCOMPLETE = 0x1 << 1,

    FUEL_SYSTEM_AVAILABLE = 0x1 << 2,
    FUEL_SYSTEM_INCOMPLETE = 0x1 << 3,

    MISFIRE_AVAILABLE = 0x1 << 4,
    MISFIRE_INCOMPLETE = 0x1 << 5,
};

/**
 * Ignition monitors available for SPARK vehicles.
 * These values come from the SAE J1979 standard.
 */
enum Obd2SparkIgnitionMonitors : Obd2CommonIgnitionMonitors {
    EGR_AVAILABLE = 0x1 << 6,
    EGR_INCOMPLETE = 0x1 << 7,

    OXYGEN_SENSOR_HEATER_AVAILABLE = 0x1 << 8,
    OXYGEN_SENSOR_HEATER_INCOMPLETE = 0x1 << 9,

    OXYGEN_SENSOR_AVAILABLE = 0x1 << 10,
    OXYGEN_SENSOR_INCOMPLETE = 0x1 << 11,

    AC_REFRIGERANT_AVAILABLE = 0x1 << 12,
    AC_REFRIGERANT_INCOMPLETE = 0x1 << 13,

    SECONDARY_AIR_SYSTEM_AVAILABLE = 0x1 << 14,
    SECONDARY_AIR_SYSTEM_INCOMPLETE = 0x1 << 15,

    EVAPORATIVE_SYSTEM_AVAILABLE = 0x1 << 16,
    EVAPORATIVE_SYSTEM_INCOMPLETE = 0x1 << 17,

    HEATED_CATALYST_AVAILABLE = 0x1 << 18,
    HEATED_CATALYST_INCOMPLETE = 0x1 << 19,

    CATALYST_AVAILABLE = 0x1 << 20,
    CATALYST_INCOMPLETE = 0x1 << 21,
};

/**
 * Ignition monitors only available for COMPRESSION vehicles.
 * These values come from the SAE J1979 standard.
 */
enum Obd2CompressionIgnitionMonitors : Obd2CommonIgnitionMonitors {
    EGR_OR_VVT_AVAILABLE = 0x1 << 6,
    EGR_OR_VVT_INCOMPLETE = 0x1 << 7,

    PM_FILTER_AVAILABLE = 0x1 << 8,
    PM_FILTER_INCOMPLETE = 0x1 << 9,

    EXHAUST_GAS_SENSOR_AVAILABLE = 0x1 << 10,
    EXHAUST_GAS_SENSOR_INCOMPLETE = 0x1 << 11,

    BOOST_PRESSURE_AVAILABLE = 0x1 << 12,
    BOOST_PRESSURE_INCOMPLETE = 0x1 << 13,

    NOx_SCR_AVAILABLE = 0x1 << 14,
    NOx_SCR_INCOMPLETE = 0x1 << 15,

    NMHC_CATALYST_AVAILABLE = 0x1 << 16,
    NMHC_CATALYST_INCOMPLETE = 0x1 << 17,
};

/**
 * The status of the vehicle's secondary air system.
 * These values come from the SAE J1979 standard.
 */
enum Obd2SecondaryAirStatus : int32_t {
    UPSTREAM = 1,
    DOWNSTREAM_OF_CATALYCIC_CONVERTER = 2,
    FROM_OUTSIDE_OR_OFF = 4,
    PUMP_ON_FOR_DIAGNOSTICS = 8,
};

/**
 * The fuel type(s) supported by a vehicle.
 * These values come from the SAE J1979 standard.
 */
enum Obd2FuelType : int32_t {
    NOT_AVAILABLE = 0,
    GASOLINE = 1,
    METHANOL = 2,
    ETHANOL = 3,
    DIESEL = 4,
    LPG = 5,
    CNG = 6,
    PROPANE = 7,
    ELECTRIC = 8,
    BIFUEL_RUNNING_GASOLINE = 9,
    BIFUEL_RUNNING_METHANOL = 10,
    BIFUEL_RUNNING_ETHANOL = 11,
    BIFUEL_RUNNING_LPG = 12,
    BIFUEL_RUNNING_CNG = 13,
    BIFUEL_RUNNING_PROPANE = 14,
    BIFUEL_RUNNING_ELECTRIC = 15,
    BIFUEL_RUNNING_ELECTRIC_AND_COMBUSTION = 16,
    HYBRID_GASOLINE = 17,
    HYBRID_ETHANOL = 18,
    HYBRID_DIESEL = 19,
    HYBRID_ELECTRIC = 20,
    HYBRID_RUNNING_ELECTRIC_AND_COMBUSTION = 21,
    HYBRID_REGENERATIVE = 22,
    BIFUEL_RUNNING_DIESEL = 23,
};

/**
 * This enum provides the canonical mapping for sensor properties that have an integer value.
 * The ordering of the values is taken from the OBD2 specification.
 * Some of the properties are represented as an integer mapping to another enum. In those cases
 * expect a comment by the property definition describing the enum to look at for the mapping.
 * Any value greater than the last reserved index is available to vendors to map their extensions.
 * While these values do not directly map to SAE J1979 PIDs, an equivalence is listed next
 * to each one to aid implementors.
 */
enum DiagnosticIntegerSensorIndex : int32_t {
    /** refer to FuelSystemStatus for a description of this value. */
    FUEL_SYSTEM_STATUS = 0, /* PID 0x03 */
    MALFUNCTION_INDICATOR_LIGHT_ON = 1, /* PID 0x01 */

    /** refer to IgnitionMonitorKind for a description of this value. */
    IGNITION_MONITORS_SUPPORTED = 2, /* PID 0x01 */

    /**
     * The value of this sensor is a bitmask that specifies whether ignition-specific
     * tests are available and whether they are complete. The semantics of the individual
     * bits in this value are given by, respectively, SparkIgnitionMonitors and
     * CompressionIgnitionMonitors depending on the value of IGNITION_MONITORS_SUPPORTED.
     */
    IGNITION_SPECIFIC_MONITORS = 3, /* PID 0x01 */
    INTAKE_AIR_TEMPERATURE = 4, /* PID 0x0F */

    /** refer to SecondaryAirStatus for a description of this value. */
    COMMANDED_SECONDARY_AIR_STATUS = 5, /* PID 0x12 */
    NUM_OXYGEN_SENSORS_PRESENT = 6, /* PID 0x13 */
    RUNTIME_SINCE_ENGINE_START = 7, /* PID 0x1F */
    DISTANCE_TRAVELED_WITH_MALFUNCTION_INDICATOR_LIGHT_ON = 8, /* PID 0x21 */
    WARMUPS_SINCE_CODES_CLEARED = 9, /* PID 0x30 */
    DISTANCE_TRAVELED_SINCE_CODES_CLEARED = 10, /* PID 0x31 */
    ABSOLUTE_BAROMETRIC_PRESSURE = 11, /* PID 0x33 */
    CONTROL_MODULE_VOLTAGE = 12, /* PID 0x42 */
    AMBIENT_AIR_TEMPERATURE = 13, /* PID 0x46 */
    TIME_WITH_MALFUNCTION_LIGHT_ON = 14, /* PID 0x4D */
    TIME_SINCE_TROUBLE_CODES_CLEARED = 15, /* PID 0x4E */
    MAX_FUEL_AIR_EQUIVALENCE_RATIO = 16, /* PID 0x4F */
    MAX_OXYGEN_SENSOR_VOLTAGE = 17, /* PID 0x4F */
    MAX_OXYGEN_SENSOR_CURRENT = 18, /* PID 0x4F */
    MAX_INTAKE_MANIFOLD_ABSOLUTE_PRESSURE = 19, /* PID 0x4F */
    MAX_AIR_FLOW_RATE_FROM_MASS_AIR_FLOW_SENSOR = 20, /* PID 0x50 */

    /** refer to FuelType for a description of this value. */
    FUEL_TYPE = 21, /* PID 0x51 */
    FUEL_RAIL_ABSOLUTE_PRESSURE = 22, /* PID 0x59 */
    ENGINE_OIL_TEMPERATURE = 23, /* PID 0x5C */
    DRIVER_DEMAND_PERCENT_TORQUE = 24, /* PID 0x61 */
    ENGINE_ACTUAL_PERCENT_TORQUE = 25, /* PID 0x62 */
    ENGINE_REFERENCE_PERCENT_TORQUE = 26, /* PID 0x63 */
    ENGINE_PERCENT_TORQUE_DATA_IDLE = 27, /* PID 0x64 */
    ENGINE_PERCENT_TORQUE_DATA_POINT1 = 28, /* PID 0x64 */
    ENGINE_PERCENT_TORQUE_DATA_POINT2 = 29, /* PID 0x64 */
    ENGINE_PERCENT_TORQUE_DATA_POINT3 = 30, /* PID 0x64 */
    ENGINE_PERCENT_TORQUE_DATA_POINT4 = 31, /* PID 0x64 */
    LAST_SYSTEM_INDEX = ENGINE_PERCENT_TORQUE_DATA_POINT4,
};

/**
 * This enum provides the canonical mapping for sensor properties that have a floating-point value.
 * The ordering of the values is taken from the OBD2 specification.
 * Any value greater than the last reserved index is available to vendors to map their extensions.
 * While these values do not directly map to SAE J1979 PIDs, an equivalence is listed next
 * to each one to aid implementors.
 */
enum DiagnosticFloatSensorIndex : int32_t {
    CALCULATED_ENGINE_LOAD = 0, /* PID 0x04 */
    ENGINE_COOLANT_TEMPERATURE = 1, /* PID 0x05 */
    SHORT_TERM_FUEL_TRIM_BANK1 = 2, /* PID 0x06 */
    LONG_TERM_FUEL_TRIM_BANK1 = 3, /* PID 0x07 */
    SHORT_TERM_FUEL_TRIM_BANK2 = 4, /* PID 0x08 */
    LONG_TERM_FUEL_TRIM_BANK2 = 5, /* PID 0x09 */
    FUEL_PRESSURE = 6, /* PID 0x0A */
    INTAKE_MANIFOLD_ABSOLUTE_PRESSURE = 7, /* PID 0x0B */
    ENGINE_RPM = 8, /* PID 0x0C */
    VEHICLE_SPEED = 9, /* PID 0x0D */
    TIMING_ADVANCE = 10, /* PID 0x0E */
    MAF_AIR_FLOW_RATE = 11, /* PID 0x10 */
    THROTTLE_POSITION = 12, /* PID 0x11 */
    OXYGEN_SENSOR1_VOLTAGE = 13, /* PID 0x14 */
    OXYGEN_SENSOR1_SHORT_TERM_FUEL_TRIM = 14, /* PID 0x14 */
    OXYGEN_SENSOR1_FUEL_AIR_EQUIVALENCE_RATIO = 15, /* PID 0x24 */
    OXYGEN_SENSOR2_VOLTAGE = 16, /* PID 0x15 */
    OXYGEN_SENSOR2_SHORT_TERM_FUEL_TRIM = 17, /* PID 0x15 */
    OXYGEN_SENSOR2_FUEL_AIR_EQUIVALENCE_RATIO = 18, /* PID 0x25 */
    OXYGEN_SENSOR3_VOLTAGE = 19, /* PID 0x16 */
    OXYGEN_SENSOR3_SHORT_TERM_FUEL_TRIM = 20, /* PID 0x16 */
    OXYGEN_SENSOR3_FUEL_AIR_EQUIVALENCE_RATIO = 21, /* PID 0x26 */
    OXYGEN_SENSOR4_VOLTAGE = 22, /* PID 0x17 */
    OXYGEN_SENSOR4_SHORT_TERM_FUEL_TRIM = 23, /* PID 0x17 */
    OXYGEN_SENSOR4_FUEL_AIR_EQUIVALENCE_RATIO = 24, /* PID 0x27 */
    OXYGEN_SENSOR5_VOLTAGE = 25, /* PID 0x18 */
    OXYGEN_SENSOR5_SHORT_TERM_FUEL_TRIM = 26, /* PID 0x18 */
    OXYGEN_SENSOR5_FUEL_AIR_EQUIVALENCE_RATIO = 27, /* PID 0x28 */
    OXYGEN_SENSOR6_VOLTAGE = 28, /* PID 0x19 */
    OXYGEN_SENSOR6_SHORT_TERM_FUEL_TRIM = 29, /* PID 0x19 */
    OXYGEN_SENSOR6_FUEL_AIR_EQUIVALENCE_RATIO = 30, /* PID 0x29 */
    OXYGEN_SENSOR7_VOLTAGE = 31, /* PID 0x1A */
    OXYGEN_SENSOR7_SHORT_TERM_FUEL_TRIM = 32, /* PID 0x1A */
    OXYGEN_SENSOR7_FUEL_AIR_EQUIVALENCE_RATIO = 33, /* PID 0x2A */
    OXYGEN_SENSOR8_VOLTAGE = 34, /* PID 0x1B */
    OXYGEN_SENSOR8_SHORT_TERM_FUEL_TRIM = 35, /* PID 0x1B */
    OXYGEN_SENSOR8_FUEL_AIR_EQUIVALENCE_RATIO = 36, /* PID 0x2B */
    FUEL_RAIL_PRESSURE = 37, /* PID 0x22 */
    FUEL_RAIL_GAUGE_PRESSURE = 38, /* PID 0x23 */
    COMMANDED_EXHAUST_GAS_RECIRCULATION = 39, /* PID 0x2C */
    EXHAUST_GAS_RECIRCULATION_ERROR = 40, /* PID 0x2D */
    COMMANDED_EVAPORATIVE_PURGE = 41, /* PID 0x2E */
    FUEL_TANK_LEVEL_INPUT = 42, /* PID 0x2F */
    EVAPORATION_SYSTEM_VAPOR_PRESSURE = 43, /* PID 0x32 */
    CATALYST_TEMPERATURE_BANK1_SENSOR1 = 44, /* PID 0x3C */
    CATALYST_TEMPERATURE_BANK2_SENSOR1 = 45, /* PID 0x3D */
    CATALYST_TEMPERATURE_BANK1_SENSOR2 = 46, /* PID 0x3E */
    CATALYST_TEMPERATURE_BANK2_SENSOR2 = 47, /* PID 0x3F */
    ABSOLUTE_LOAD_VALUE = 48, /* PID 0x43 */
    FUEL_AIR_COMMANDED_EQUIVALENCE_RATIO = 49, /* PID 0x44 */
    RELATIVE_THROTTLE_POSITION = 50, /* PID 0x45 */
    ABSOLUTE_THROTTLE_POSITION_B = 51, /* PID 0x47 */
    ABSOLUTE_THROTTLE_POSITION_C = 52, /* PID 0x48 */
    ACCELERATOR_PEDAL_POSITION_D = 53, /* PID 0x49 */
    ACCELERATOR_PEDAL_POSITION_E = 54, /* PID 0x4A */
    ACCELERATOR_PEDAL_POSITION_F = 55, /* PID 0x4B */
    COMMANDED_THROTTLE_ACTUATOR = 56, /* PID 0x4C */
    ETHANOL_FUEL_PERCENTAGE = 57,/* PID 0x52 */
    ABSOLUTE_EVAPORATION_SYSTEM_VAPOR_PRESSURE = 58, /* PID 0x53 */
    SHORT_TERM_SECONDARY_OXYGEN_SENSOR_TRIM_BANK1 = 59, /* PID 0x55 */
    SHORT_TERM_SECONDARY_OXYGEN_SENSOR_TRIM_BANK2 = 60, /* PID 0x57 */
    SHORT_TERM_SECONDARY_OXYGEN_SENSOR_TRIM_BANK3 = 61,/* PID 0x55 */
    SHORT_TERM_SECONDARY_OXYGEN_SENSOR_TRIM_BANK4 = 62, /* PID 0x57 */
    LONG_TERM_SECONDARY_OXYGEN_SENSOR_TRIM_BANK1 = 63, /* PID 0x56 */
    LONG_TERM_SECONDARY_OXYGEN_SENSOR_TRIM_BANK2 = 64, /* PID 0x58 */
    LONG_TERM_SECONDARY_OXYGEN_SENSOR_TRIM_BANK3 = 65, /* PID 0x56 */
    LONG_TERM_SECONDARY_OXYGEN_SENSOR_TRIM_BANK4 = 66, /* PID 0x58 */
    RELATIVE_ACCELERATOR_PEDAL_POSITION = 67, /* PID 0x5A */
    HYBRID_BATTERY_PACK_REMAINING_LIFE = 68, /* PID 0x5B */
    FUEL_INJECTION_TIMING = 69, /* PID 0x5D */
    ENGINE_FUEL_RATE = 70, /* PID 0x5E */
    LAST_SYSTEM_INDEX = ENGINE_FUEL_RATE,
};

/**
 * This enum lists the types of supported VMS messages. It is used as the first
 * integer in the vehicle property integers array and determines how the rest of
 * the message is decoded.
 */
enum VmsMessageType : int32_t {
    /**
     * A request from the subscribers to the VMS service to subscribe to a layer.
     *
     * This message type uses enum VmsMessageWithLayerIntegerValuesIndex.
     */
    SUBSCRIBE = 1,

    /**
     * A request from the subscribers to the VMS service to subscribe to a layer from a specific publisher.
     *
     * This message type uses enum VmsMessageWithLayerAndPublisherIdIntegerValuesIndex.
     */
    SUBSCRIBE_TO_PUBLISHER = 2,

    /**
     * A request from the subscribers to the VMS service to unsubscribes from a layer.
     *
     * This message type uses enum VmsMessageWithLayerIntegerValuesIndex.
     */
    UNSUBSCRIBE = 3,

    /**
     * A request from the subscribers to the VMS service to unsubscribes from a layer from a specific publisher.
     *
     * This message type uses enum VmsMessageWithLayerAndPublisherIdIntegerValuesIndex.
     */
    UNSUBSCRIBE_TO_PUBLISHER = 4,

    /**
     * Information from the publishers to the VMS service about the layers which the client can publish.
     *
     * This message type uses enum VmsOfferingMessageIntegerValuesIndex.
     */
    OFFERING = 5,

    /**
     * A request from the subscribers to the VMS service to get the available layers.
     *
     * This message type uses enum VmsBaseMessageIntegerValuesIndex.
     */
    AVAILABILITY_REQUEST = 6,

    /**
     * A request from the publishers to the VMS service to get the layers with subscribers.
     *
     * This message type uses enum VmsBaseMessageIntegerValuesIndex.
     */
    SUBSCRIPTIONS_REQUEST = 7,

    /**
     * A response from the VMS service to the subscribers to a VmsMessageType.AVAILABILITY_REQUEST
     *
     * This message type uses enum VmsAvailabilityStateIntegerValuesIndex.
     */
    AVAILABILITY_RESPONSE = 8,

    /**
     * A notification from the VMS service to the subscribers on a change in the available layers.
     *
     * This message type uses enum VmsAvailabilityStateIntegerValuesIndex.
     */
    AVAILABILITY_CHANGE = 9,

    /**
     * A response from the VMS service to the publishers to a VmsMessageType.SUBSCRIPTIONS_REQUEST
     *
     * This message type uses enum VmsSubscriptionsStateIntegerValuesIndex.
     */
    SUBSCRIPTIONS_RESPONSE = 10,

    /**
     * A notification from the VMS service to the publishers on a change in the layers with subscribers.
     *
     * This message type uses enum VmsSubscriptionsStateIntegerValuesIndex.
     */
    SUBSCRIPTIONS_CHANGE = 11,

    /**
     * A message from the VMS service to the subscribers or from the publishers to the VMS service
     * with a serialized VMS data packet as defined in the VMS protocol.
     *
     * This message type uses enum VmsBaseMessageIntegerValuesIndex.
     */
    DATA = 12,
};

/**
 * Every VMS message starts with the type of the message from the VmsMessageType enum.
 * Messages with no parameters such as VmsMessageType.AVAILABILITY_REQUEST,
 * VmsMessageType.SUBSCRIPTIONS_REQUEST and VmsMessageType.DATA are also based on this enum.
 */
enum VmsBaseMessageIntegerValuesIndex : int32_t {
    /* The message type as enumerated by VmsMessageType enum. */
    MESSAGE_TYPE = 0,
};

/*
 * A VMS message with a layer is sent as part of a VmsMessageType.SUBSCRIBE or
 * VmsMessageType.UNSUBSCRIBE messages.
 *
 * The layer type is defined in the VMS protocol, and the subtype and version are
 * controlled by the implementer of the publisher.
 */
enum VmsMessageWithLayerIntegerValuesIndex : VmsBaseMessageIntegerValuesIndex {
    LAYER_TYPE = 1,
    LAYER_SUBTYPE = 2,
    LAYER_VERSION = 3,
};

/*
 * A VMS message with a layer and publisher ID is sent as part of a
 * VmsMessageType.SUBSCRIBE_TO_PUBLISHER and VmsMessageType.UNSUBSCRIBE_TO_PUBLISHER messages.
 */
enum VmsMessageWithLayerAndPublisherIdIntegerValuesIndex : VmsMessageWithLayerIntegerValuesIndex {
    PUBLISHER_ID = 4,
};

/*
 * An offering can be sent by publishers as part of VmsMessageType.OFFERING in order to
 * advertise which layers they can publish and under which constraints: e.g., I can publish Layer X
 * if someone else will publish Layer Y.
 * The offering contains the publisher ID which was assigned to the publisher by the VMS service.
 * A single offering is represented as:
 * - Layer type
 * - Layer subtype
 * - Layer version
 * - Number of dependencies (N)
 * - N x (Layer type, Layer subtype, Layer version)
 */
enum VmsOfferingMessageIntegerValuesIndex : VmsBaseMessageIntegerValuesIndex {
    PUBLISHER_ID = 1,
    NUMBER_OF_OFFERS = 2,
    OFFERING_START = 3,
};

/**
 * A subscriptions state is sent to the publishers in response to a change in the subscriptions
 * as part of a VmsMessageType.SUBSCRIPTIONS_CHANGE, or in response to a
 * VmsMessageType.SUBSCRIPTIONS_REQUEST message as part of VmsMessageType.SUBSCRIPTIONS_RESPONSE.
 * The VMS service issues monotonically increasing sequence numbers, and in case a subscriber receives
 * a smaller sequnce number it should ignore the message.
 * The subscriptions are sent as a list of layers followed by a list of associated layers:
 * {Sequence number, N, M, N x layer, M x associated layer}
 * A subscribed layer is represented as three integers:
 * - Layer type
 * - Layer subtype
 * - Layer version
 * A subscribed associated layer is a layer with a list of publisher IDs. It is represented as:
 * - Layer type
 * - Layer subtype
 * - Layer version
 * - Number of publisher IDs (N)
 * - N x publisher ID
 */
enum VmsSubscriptionsStateIntegerValuesIndex : VmsBaseMessageIntegerValuesIndex {
    SEQUENCE_NUMBER = 1,
    NUMBER_OF_LAYERS = 2,
    NUMBER_OF_ASSOCIATED_LAYERS = 3,
    SUBSCRIPTIONS_START = 4,
};

/**
 * An availability state is sent to the subscribers in response to a change in the available
 * layers as part of a VmsMessageType.AVAILABILITY_CHANGE message, or in response to a
 * VmsMessageType.AVAILABILITY_REQUEST message as part of a VmsMessageType.AVAILABILITY_RESPONSE.
 * The VMS service issues monotonically increasing sequence numbers, and in case a subscriber receives
 * a smaller sequnce number, it should ignore the message.
 * An available associated layer is a layer with a list of publisher IDs:
 * - Layer type
 * - Layer subtype
 * - Layer version
 * - Number of publisher IDs (N)
 * - N x publisher ID
*/
enum VmsAvailabilityStateIntegerValuesIndex : VmsBaseMessageIntegerValuesIndex {
    SEQUENCE_NUMBER = 1,
    NUMBER_OF_ASSOCIATED_LAYERS = 2,
    LAYERS_START = 3,
};

