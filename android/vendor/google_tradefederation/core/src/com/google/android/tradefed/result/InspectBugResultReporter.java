/*
 * Copyright (C) 2013 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.android.tradefed.result;

import com.android.ddmlib.testrunner.TestIdentifier;
import com.android.loganalysis.item.BugreportItem;
import com.android.loganalysis.item.CompactMemInfoItem;
import com.android.loganalysis.item.CpuInfoItem;
import com.android.loganalysis.item.DumpsysItem;
import com.android.loganalysis.item.GfxInfoItem;
import com.android.loganalysis.item.IItem;
import com.android.loganalysis.item.KernelLogItem;
import com.android.loganalysis.item.LogcatItem;
import com.android.loganalysis.item.MemInfoItem;
import com.android.loganalysis.item.MonkeyLogItem;
import com.android.loganalysis.item.ProcrankItem;
import com.android.loganalysis.item.TopItem;
import com.android.loganalysis.parser.BugreportParser;
import com.android.loganalysis.parser.CompactMemInfoParser;
import com.android.loganalysis.parser.CpuInfoParser;
import com.android.loganalysis.parser.DumpsysParser;
import com.android.loganalysis.parser.GfxInfoParser;
import com.android.loganalysis.parser.KernelLogParser;
import com.android.loganalysis.parser.LogcatParser;
import com.android.loganalysis.parser.MemInfoParser;
import com.android.loganalysis.parser.MonkeyLogParser;
import com.android.loganalysis.parser.ProcrankParser;
import com.android.loganalysis.parser.TopParser;
import com.android.tradefed.build.DeviceBuildDescriptor;
import com.android.tradefed.build.IBuildInfo;
import com.android.tradefed.config.Option;
import com.android.tradefed.config.OptionClass;
import com.android.tradefed.invoker.IInvocationContext;
import com.android.tradefed.invoker.TestInvocation;
import com.android.tradefed.log.LogUtil.CLog;
import com.android.tradefed.result.ILogSaver;
import com.android.tradefed.result.ILogSaverListener;
import com.android.tradefed.result.ITestInvocationListener;
import com.android.tradefed.result.ITestSummaryListener;
import com.android.tradefed.result.InputStreamSource;
import com.android.tradefed.result.LogDataType;
import com.android.tradefed.result.LogFile;
import com.android.tradefed.result.TestSummary;
import com.android.tradefed.util.Bugreport;
import com.android.tradefed.util.FileUtil;
import com.android.tradefed.util.IRunUtil;
import com.android.tradefed.util.RunUtil;
import com.android.tradefed.util.StreamUtil;
import com.android.tradefed.util.net.HttpHelper;
import com.android.tradefed.util.net.IHttpHelper;
import com.google.android.tradefed.util.SsoClientTransport;
import com.google.api.client.http.ByteArrayContent;
import com.google.api.client.http.GenericUrl;
import com.google.api.client.http.HttpBackOffUnsuccessfulResponseHandler;
import com.google.api.client.http.HttpContent;
import com.google.api.client.http.HttpRequest;
import com.google.api.client.http.HttpRequestFactory;
import com.google.api.client.http.HttpResponse;
import com.google.api.client.http.HttpUnsuccessfulResponseHandler;
import com.google.api.client.http.javanet.NetHttpTransport;
import com.google.api.client.util.BackOff;
import com.google.api.client.util.ExponentialBackOff;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

/**
 * Result reporter that collects logs generated by the tests and uploads them to the bug inspector.
 */
@OptionClass(alias = "inspect-bug")
public class InspectBugResultReporter extends AbstractRemoteResultReporter
        implements ITestSummaryListener, ILogSaverListener {
    private static final Set<String> SKIPPED_LOGCATS =
            new HashSet<String>(
                    Arrays.asList(
                            new String[] {
                                TestInvocation.getDeviceLogName(TestInvocation.Stage.ERROR),
                                TestInvocation.getDeviceLogName(TestInvocation.Stage.SETUP),
                                TestInvocation.getDeviceLogName(TestInvocation.Stage.TEARDOWN)
                            }));
    private static final int SSO_TIMEOUT = 60 * 1000; // 60 seconds

    /**
     * Represents the methods, keys for log data, and expected id keys in the response.
     */
    protected enum PostMethod {
        CREATE_RUN("/post/create_run", null, "run_id"),
        UPDATE_RUN("/post/update_run", null, null),
        ADD_BUGREPORT("/post/add_bugreport", "bugreport", "bugreport_id"),
        ADD_MONKEY_LOG("/post/add_monkey_log", "monkey_log", "monkey_log_id"),
        ADD_LOGCAT("/post/add_logcat", "logcat", "logcat_id"),
        ADD_KERNEL_LOG("/post/add_kernel_log", "kernel_log", "kernel_log_id"),
        ADD_MEM_INFO("/post/add_mem_info", "mem_info", "mem_info_id"),
        ADD_PROCRANK("/post/add_procrank", "procrank", "procrank_id"),
        ADD_TOP("/post/add_top", "top", "top_id"),
        ADD_DUMPSYS("/post/add_dumpsys", "dumpsys", "dumpsys_id"),
        ADD_COMPACT_MEMINFO("/post/add_compact_meminfo", "compact_meminfo", "compact_meminfo_id"),
        ADD_GFX_INFO("/post/add_gfx_info", "gfx_info", "gfx_info_id"),
        ADD_CPU_INFO("/post/add_cpu_info", "cpu_info", "cpu_info_id"),
        ADD_TRADEFED_LOG("/post/add_tradefed_log", "tradefed_log", "tradefed_log_id"),
        ADD_COMPAT_LOG("/post/add_compat_log", "compat_log", "compat_log_id"),
        ADD_MEMORY_HEALTH("/post/add_memory_health", "memory_health", null),
        ADD_TEST_FAILURE("/post/add_test_failure", "test_failure", null),
        ADD_LINKS("/post/add_links", "add_links", null);

        private final String mMethod;
        private final String mPostKey;
        private final String mResponseKey;

        PostMethod(String method, String postKey, String responseKey) {
            mMethod = method;
            mPostKey = postKey;
            mResponseKey = responseKey;
        }

        public String getMethod() {
            return mMethod;
        }

        public String getPostKey() {
            return mPostKey;
        }

        public String getResponseKey() {
            return mResponseKey;
        }

        @Override
        public String toString() {
            return mMethod;
        }
    }

    @Option(name = "suite-key", description="suite to post to.")
    private String mSuiteKey = null;

    @Option(name = "suite-instance-key", description =
            "suite instance to post to, useful if there are multiple runs with the same build." +
            "If not set, it will default to the suite key passed to inspect bug.")
    private String mSuiteInstanceKey = null;

    @Option(name = "suite-key-prefix", description =
            "the prefix for the suite key. If suite-key is not set and suite-key-prefix is set, " +
            "then suite key will be a combination of the prefix and the test tag")
    private String mSuiteKeyPrefix = null;

    @Option(name = "description", description =
            "the descripiton of the run. Will overwrite the description for the suite-instance.")
    private String mDescription = null;

    @Option(name = "host", description = "the inspect bug host")
    private String mSecondaryHost = "http://android-inspect-bug-posting.corp.google.com";

    @Option(
        name = "enable-secondary-posting",
        description = "If enabled also upload results to legacy dashboard."
    )
    private boolean mEnableSecondaryPosting = false;

    @Option(name = "appengine-host", description = "App Engine host running inspectbug")
    private String mAppEngineHost = "https://inspectbug.googleplex.com";

    @Option(name = "disable-inspect-bug", description = "disable posting to inspect-bug")
    protected boolean mDisable = false;

    @Option(name = "report-invocation-failures", description = "Whether or not to report " +
            "invocation failures to the InspectBug backend.")
    private boolean mReportInvFailures = false;

    @Option(name = "only-report-invocation-failures", description = "If set, do _not_ report " +
            "anything other than invocation failures to the InspectBug backend.  Implies " +
            "--report-invocation-failures.")
    protected boolean mOnlyReportInvFailures = false;

    @Option(name = "ignore-alias", description =
            "tell inspect bug to ignore the alias when creating a branch.")
    private boolean mIgnoreAlias = false;

    @Option(name = "procedure-key", description =
            "the key to the procedure to run on the inspect bug server after update run.")
    private String mProcedureKey = null;

    @Option(name = "procedure-data", description =
            "extra procedure data to pass to inspect bug after update run. May be repeated")
    private Map<String, String> mProcedureData = new HashMap<>();

    @Option(name = "override-build-flavor", description =
            "specifies a custom build flavor to pass to inspect bug.")
    private String mBuildFlavorOverride = null;

    @Option(name = "post-testrunner-exceptions",
            description="Also include exceptions caught by the instrumentation")
    private boolean mPostTestRunnerExceptions = false;

    @Option(name = "show-full-requests",
            description="Log the full text of all requests and responses")
    private boolean mShowFullRequests = false;

    protected boolean mRunCreated = false;
    private Integer mSecondaryRunId = null;
    private Integer mAppEngineRunId = null;
    private String mSummaryUrl = null;

    private int mTestFailedCount = 0;
    private int mTestCount = 0;
    private boolean mInvocationFailed = false;
    private String mPostError = null;

    /**
     * Create an {@link InspectBugResultReporter}.
     */
    public InspectBugResultReporter() {
        super();
    }

    /**
     * Create an {@link InspectBugResultReporter} with suite key and suite instance key set.
     * <p>
     * Exposed for unit testing.
     * </p>
     */
    InspectBugResultReporter(String suiteKey, String suiteInstanceKey) {
        this();
        mSuiteKey = suiteKey;
        mSuiteInstanceKey = suiteInstanceKey;
    }

    /** {@inheritDoc} */
    @Override
    public void invocationStarted(IInvocationContext context) {
        super.invocationStarted(context);

        if (mDisable) {
            return;
        }
        // Make sure that suite-key or suite-key-prefix is set.
        if (mSuiteKey == null && mSuiteKeyPrefix == null) {
            throw new RuntimeException("suite-key or suite-key-prefix must be set");
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void testLog(String dataName, LogDataType dataType, InputStreamSource source) {
        super.testLog(dataName, dataType, source);
        // Ignore
    }

    /** {@inheritDoc} */
    @Override
    public void testLogSaved(
            String dataName, LogDataType dataType, InputStreamSource source, LogFile file) {
        CLog.i(dataName);
        if (mDisable || mOnlyReportInvFailures) {
            CLog.i("Posting disabled");
            return;
        } else if (dataType == LogDataType.LOGCAT && SKIPPED_LOGCATS.contains(dataName)) {
            CLog.i("Skip analyzing logcat, %s", dataName);
            return;
        }
        switch (dataType) {
            case BUGREPORT:
            case BUGREPORTZ:
            case MONKEY_LOG:
            case LOGCAT:
            case KERNEL_LOG:
            case MEM_INFO:
            case PROCRANK:
            case TOP:
            case DUMPSYS:
            case COMPACT_MEMINFO:
            case GFX_INFO:
            case CPU_INFO:
                if (!mRunCreated) {
                    // Create the run
                    mRunCreated = true;
                    setRunId(createRun(getCurrentTimestamp()));
                }
                Date timestamp = parseTimestamp(file);
                postLog(dataType, source.createInputStream(), file, timestamp);
                break;
            default:
                postAdditionalLog(dataName, dataType, source, file);
                break;
        }
    }

    /**
     * Get current time stamp. Can be overriden to parse from file.
     *
     * @param file a {@link LogFile} that can be used to get the time stamp.
     * @return a {@link Date} of the current time stamp.
     */
    protected Date parseTimestamp(LogFile file) {
        return getCurrentTimestamp();
    }

    /**
     * Callback for subclasses to implement, so they can post other types of log files.
     * @param dataName name of the saved log file
     * @param dataType data type of the saved logfile
     * @param source stream connected to the saved log file
     * @param file additiona data about the saved log file.
     */
    protected void postAdditionalLog(String dataName, LogDataType dataType, InputStreamSource source,
            LogFile file) {
        // Do nothing, let subclasses overwrite for additional functionality
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void putSummary(List<TestSummary> summaries) {
        if (mDisable) {
            return;
        }
        // By convention, only store the first summary that we see as the detail URL.  Overwrite it
        // if we see a result set that is an instance of StatisticsTestSummary.
        if (summaries.isEmpty()) {
            return;
        }

        mSummaryUrl = summaries.get(0).getSummary().getString();
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void invocationFailed(Throwable cause) {
        super.invocationFailed(cause);

        mInvocationFailed = true;
        if (mDisable || !(mReportInvFailures || mOnlyReportInvFailures)) {
            return;
        }
    }

    /**
     * Get an {@link IRunUtil} to use.
     * <p />
     * Exposed for unit testing
     */
    IRunUtil getRunUtil() {
        return RunUtil.getDefault();
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void invocationEnded(long elapsedTime) {
        super.invocationEnded(elapsedTime);
        if (!mDisable && haveRunId() && mSummaryUrl != null) {
            updateRun();
        }

        if (mPostError != null) {
            notifyReportError("inspect-bug", mPostError);
        }
    }

    /** {@inheritDoc} */
    @Override
    public void testEnded(TestIdentifier test, long endTime, Map<String, String> testMetrics) {
        mTestCount += 1;
        super.testEnded(test, endTime, testMetrics);
    }

    /** {@inheritDoc} */
    @Override
    public void testFailed(TestIdentifier test, String trace) {
        mTestFailedCount += 1;
        super.testFailed(test, trace);
    }

    /** {@inheritDoc} */
    @Override
    public int getNumTotalTests() {
        return mTestCount;
    }

    /** {@inheritDoc} */
    @Override
    public int getNumAllFailedTests() {
        return mTestFailedCount;
    }

    /**
     * Get whether {@link ITestInvocationListener#invocationFailed(Throwable)} was called.
     */
    protected boolean getInvocationFailed() {
        return mInvocationFailed;
    }

    /**
     * Allows subclasses to create a run.
     * @return the run id of the created run
     */
    protected Integer createRun() {
        if (!mRunCreated) {
            setRunId(createRun(new Date()));
            mRunCreated = true;
        }
        return getRunId();
    }

    /**
     * Create a run on inspect bug
     *
     * @param timestamp The timestamp of the run.
     * @return The id of the run, or null if run was not created.
     */
    protected Integer createRun(Date timestamp) {
        final PostMethod method = PostMethod.CREATE_RUN;

        try {
            IBuildInfo buildInfo = getPrimaryBuildInfo();
            JSONObject postData = new JSONObject();

            JSONObject suite = new JSONObject();
            if (mSuiteKey != null) {
                suite.put("key", mSuiteKey);
            } else if (mSuiteKeyPrefix != null) {
                suite.put("key", mSuiteKeyPrefix + buildInfo.getTestTag());
            }
            suite.put("instance_key", getSuiteInstanceKey());
            suite.put("description", getDescription());
            postData.put("suite", suite);

            boolean productAdded = false;
            JSONArray auxBuilds = new JSONArray();
            if (DeviceBuildDescriptor.describesDeviceBuild(buildInfo)) {
                final DeviceBuildDescriptor deviceBuildInfo = new DeviceBuildDescriptor(buildInfo);
                if (buildInfo.getBuildId() != null &&
                        !buildInfo.getBuildId().equals(deviceBuildInfo.getDeviceBuildId())) {
                    JSONObject auxBuild = new JSONObject();
                    auxBuild.put("incremental", deviceBuildInfo.getDeviceBuildId());
                    auxBuild.put("alias", deviceBuildInfo.getDeviceBuildAlias());
                    auxBuild.put("flavor", deviceBuildInfo.getDeviceBuildFlavor());
                    addProductTarget(auxBuild, deviceBuildInfo.getDeviceBuildFlavor());

                    auxBuilds.put(auxBuild);
                    productAdded = true;
                }
            }

            if (auxBuilds.length() > 0) {
                postData.put("aux_builds", auxBuilds);
            }

            JSONObject build = new JSONObject();
            build.put("incremental", buildInfo.getBuildId());
            build.put("alias", buildInfo.getBuildAttributes().get("build_alias"));
            build.put("branch", buildInfo.getBuildBranch());
            build.put("ignore_alias", mIgnoreAlias);
            String buildFlavor = (mBuildFlavorOverride != null ?
                    mBuildFlavorOverride : buildInfo.getBuildFlavor());
            build.put("flavor", buildFlavor);
            if (!productAdded) {
                addProductTarget(build, buildFlavor);
            }
            postData.put("build", build);

            postData.put("timestamp", timestamp);
            postData.put("serial_number", buildInfo.getDeviceSerial());

            Integer run = post(method, postData);
            CLog.i("Created run %d", run);
            return run;
        } catch (JSONException e) {
            CLog.w("Post %s failed: %s", method, e.toString());
        }
        return null;
    }

    /**
     * Helper method to derive the product and target from the flavor and add it to the
     * build {@link JSONObject}.
     */
    private void addProductTarget(JSONObject build, String flavor) throws JSONException {
        if (flavor == null) {
            return;
        }

        if (flavor.endsWith("-user")) {
            build.put("product", flavor.substring(0, flavor.lastIndexOf("-")));
            build.put("target", "user");
        } else if (flavor.endsWith("-userdebug")) {
            build.put("product", flavor.substring(0, flavor.lastIndexOf("-")));
            build.put("target", "userdebug");
        } else if (flavor.endsWith("-eng")) {
            build.put("product", flavor.substring(0, flavor.lastIndexOf("-")));
            build.put("target", "eng");
        } else {
            // If not set default to userdebug
            build.put("product", flavor);
            build.put("target", "userdebug");
        }
    }

    /**
     * Updates a run on inspect bug with the final summary url.
     */
    protected void updateRun() {
        PostMethod method = PostMethod.UPDATE_RUN;

        if (!haveRunId()) {
            CLog.w("Run id is not set, cannot post");
            return;
        }

        try {
            JSONObject postData = new JSONObject();
            postData.put("run_id", getRunId());
            if (mSummaryUrl != null) {
                postData.put("url", mSummaryUrl);
            }
            JSONObject attributes = new JSONObject();
            getAttributes(attributes);
            postData.put("attributes", attributes);
            postData.put("procedure_key", mProcedureKey);
            if (mProcedureKey != null && mProcedureData.size() > 0) {
                postData.put("procedure_data", new JSONObject(mProcedureData));
            }
            post(method, postData);
        } catch (JSONException e) {
            CLog.w("Post %s failed: %s", method, e.toString());
        }
    }

    /**
     * Allows the subclasses to set additional attributes.
     */
    protected void getAttributes(JSONObject attributes) throws JSONException {
        attributes.put("test-count", getNumTotalTests());
        attributes.put("test-failed", getNumAllFailedTests());
        attributes.put("invocation-failed", getInvocationFailed());
    }

    /**
     * Post log data to inspect bug.
     *
     * @param dataType The method to use
     * @param source The input stream of the log
     * @param log The saved {@link LogFile}.
     * @param timestamp The timestamp the file was created.
     * @return The id of the item posted or {@code null} if there was an error.
     */
    protected Integer postLog(LogDataType dataType, InputStream source, LogFile log, Date timestamp) {
        if (!haveRunId()) {
            CLog.w("Run id is not set, cannot post");
            return null;
        }

        if (source == null) {
            CLog.w("Source is not set, cannot post");
            return null;
        }

        PostMethod method = null;
        IItem item = null;
        try {
            JSONObject postData = new JSONObject();
            postData.put("run_id", getRunId());
            postData.put("timestamp", timestamp);
            postData.put("filepath", log.getPath());
            postData.put("url", log.getUrl());

            switch (dataType) {
                case BUGREPORT:
                    method = PostMethod.ADD_BUGREPORT;
                    item = parseBugreport(source);
                    break;
                case BUGREPORTZ:
                    method = PostMethod.ADD_BUGREPORT;
                    item = parseBugreport(getMainFileSource(source));
                    break;
                case MONKEY_LOG:
                    method = PostMethod.ADD_MONKEY_LOG;
                    item = parseMokeyLog(source);
                    break;
                case LOGCAT:
                    method = PostMethod.ADD_LOGCAT;
                    item = parseLogcat(source);
                    break;
                case KERNEL_LOG:
                    method = PostMethod.ADD_KERNEL_LOG;
                    item = parseKernelLog(source);
                    break;
                case MEM_INFO:
                    method = PostMethod.ADD_MEM_INFO;
                    item = parseMemInfo(source);
                    break;
                case PROCRANK:
                    method = PostMethod.ADD_PROCRANK;
                    item = parseProcrank(source);
                    break;
                case TOP:
                    method = PostMethod.ADD_TOP;
                    item = parseTop(source);
                    break;
                case DUMPSYS:
                    method = PostMethod.ADD_DUMPSYS;
                    item = parseDumpsys(source);
                    break;
                case COMPACT_MEMINFO:
                    method = PostMethod.ADD_COMPACT_MEMINFO;
                    item = parseCompactMeminfo(source);
                    break;
                case GFX_INFO:
                    method = PostMethod.ADD_GFX_INFO;
                    item = parseGfxInfo(source);
                    break;
                case CPU_INFO:
                    method = PostMethod.ADD_CPU_INFO;
                    item = parseCpuInfo(source);
                    break;
                default:
                    return null;
            }

            if (item == null) {
                CLog.e("Log could not be parsed.");
                return null;
            }

            postData.put(method.getPostKey(), item.toJson());

            return post(method, postData);
        } catch (JSONException e) {
            CLog.w("Post %s failed: %s", method, e.toString());
        } catch (IOException e) {
            CLog.w("Post %s failed: %s", method, e.toString());
        }
        return null;
    }

    /**
     * A helper method for posting to inspect bug. Exposed for unit testing.
     *
     * @param method The post method.
     * @param postData The post data.
     *
     * @return The id of the item posted or {@code null} if there was an error or if
     * {@link PostMethod#getResponseKey()} is {@code null}.
     */
    protected Integer post(PostMethod method, JSONObject postData) {
        secondaryPost(method, postData);
        try {
            String url = getHost() + method.getMethod();
            CLog.d("Posting to url: %s", url);
            if (mShowFullRequests) {
                CLog.d("Request:\n%s", postData.toString());
            }
            String response = doSsoPost(url, postData.toString(), "application/json");
            if (mShowFullRequests) {
                CLog.d("Response:\n%s", response.toString());
            }
            JSONObject result = new JSONObject(response);

            if (!result.has("status") || !"OK".equals(result.get("status"))) {
                logPostError("Post %s failed: Response was %s", url, result.toString());
                return -1;
            }

            if (method.getResponseKey() == null) {
                return null;
            }

            if (result.has(method.getResponseKey())) {
                return Integer.parseInt(result.getString(method.getResponseKey()));
            }

            logPostError("Post %s failed: %s not found in response", url, method.getResponseKey());
        } catch (JSONException | IOException | NumberFormatException e) {
            logPostError("Post %s failed: %s", method, e.toString());
        }

        return -1;
    }

    private void secondaryPost(PostMethod method, JSONObject postData) {
        if (!mEnableSecondaryPosting || "".equals(getSecondaryHost())) {
            return;
        }
        try {
            if (postData.has("run_id")) {
                JSONObject copy = new JSONObject();
                Iterator<?> i = postData.keys();
                while (i.hasNext()) {
                    String name = (String)i.next();
                    copy.put(name, postData.get(name));
                }
                copy.put("run_id", getSecondaryRunId());
                postData = copy;
            }
            String url = getSecondaryHost() + method.getMethod();
            CLog.d("Secondary posting to: %s", url);
            String response = doPost(url, postData.toString(), "application/json");
            CLog.d("Response:\n%s", response);
            JSONObject result = new JSONObject(response);

            if (!result.has("status") || !"OK".equals(result.get("status"))) {
                logPostError("Post %s failed: Response was %s", url, result.toString());
                return;
            }
            if (result.has("run_id")) {
                setSecondaryRunId(Integer.parseInt(result.getString("run_id")));
                CLog.d("Got secondary run id: %s", getSecondaryRunId());
            }
        } catch (JSONException | NumberFormatException | IOException e) {
            logPostError("Post %s failed: %s", method, e.toString());
        }
    }

    private String doPost(String url, String payload, String contentType) throws IOException {
        return doPost(url, payload, contentType, new NetHttpTransport().createRequestFactory());
    }

    private String doSsoPost(String url, String payload, String contentType) throws IOException {
        return doPost(url, payload, contentType, new SsoClientTransport().createRequestFactory());
    }

    protected String doPost(
            String url, String payload, String contentType, HttpRequestFactory requestFactory)
            throws IOException {
        IOException lastError = null;
        ExponentialBackOff backOff = new ExponentialBackOff();
        int attempts = 0;
        while (true) {
            try {
                GenericUrl dest = new GenericUrl(url);
                HttpContent content = new ByteArrayContent(contentType, payload.getBytes());
                HttpRequest request = requestFactory.buildPostRequest(dest, content);
                request.setUnsuccessfulResponseHandler(new ResponseHandler());
                request.setConnectTimeout(SSO_TIMEOUT);
                HttpResponse response = request.execute();
                return response.parseAsString();
            } catch (IOException e) {
                attempts++;
                logPostError("Request %d to %s failed: %s.", attempts, url, e.toString());
                lastError = e;
                long interval = backOff.nextBackOffMillis();
                if (interval == BackOff.STOP) {
                    break;
                }
                getRunUtil().sleep(interval);
            }
        }
        throw lastError;
    }

    private class ResponseHandler implements HttpUnsuccessfulResponseHandler {

        private HttpUnsuccessfulResponseHandler mHandler;

        public ResponseHandler() {
            mHandler = new HttpBackOffUnsuccessfulResponseHandler(new ExponentialBackOff());
        }

        @Override
        public boolean handleResponse(HttpRequest request, HttpResponse response,
                                      boolean supportsRetry) throws IOException {
            logPostError("Request to %s failed: %d %s",
                         request.getUrl(), response.getStatusCode(), response.getStatusMessage());
            try {
                CLog.w("\n%s", response.parseAsString());
            } catch (IOException e) {
                CLog.w("Error reading response: %s", e);
            }
            return mHandler.handleResponse(request, response, supportsRetry);
        }
    }

    void logPostError(String format, Object... args) {
        final String msg = String.format(format, args);
        if (mPostError == null) {
            mPostError = msg;
        } else {
            mPostError += "\n";
            mPostError += msg;
        }
        CLog.w(msg);
    }

    /**
     * Helper method to convert a input stream source into a {@link List} of {@link String}s.
     */
    private List<String> getLines(InputStream source) throws IOException {
        List<String> lines = new LinkedList<>();
        BufferedReader reader = new BufferedReader(new InputStreamReader(source));
        String line;
        try {
            while ((line = reader.readLine()) != null) {
                lines.add(line);
            }
            return lines;
        } finally {
            StreamUtil.close(reader);
        }
    }

    protected Integer getRunId() {
        return mAppEngineRunId;
    }

    protected void setRunId(Integer id) {
        mAppEngineRunId = id;
    }

    private boolean haveRunId() {
        return getRunId() != null && getRunId() != -1;
    }

    /**
     * Parse a bugreport. Exposed for unit testing.
     */
    BugreportItem parseBugreport(InputStream source) throws IOException {
        return new BugreportParser().parse(new BufferedReader(new InputStreamReader(source)));
    }

    /**
     * Parse a monkey log. Exposed for unit testing.
     */
    MonkeyLogItem parseMokeyLog(InputStream source) throws IOException {
        return new MonkeyLogParser().parse(new BufferedReader(new InputStreamReader(source)));
    }

    /**
     * Parse a logcat. Exposed for unit testing.
     */
    LogcatItem parseLogcat(InputStream source) throws IOException {
        LogcatParser logcatParser = new LogcatParser();
        if (mPostTestRunnerExceptions) {
            logcatParser.addJavaCrashTag("I", "TestRunner", LogcatParser.JAVA_CRASH);
        }
        return logcatParser.parse(new BufferedReader(new InputStreamReader(source)));
    }

    /**
     * Parse a kernel log. Exposed for unit testing.
     */
    KernelLogItem parseKernelLog(InputStream source) throws IOException {
        return new KernelLogParser().parse(getLines(source));
    }

    /**
     * Parse mem info output. Exposed for unit testing.
     */
    MemInfoItem parseMemInfo(InputStream source) throws IOException {
        return new MemInfoParser().parse(getLines(source));
    }

    /**
     * Parse procrank output. Exposed for unit testing.
     */
    ProcrankItem parseProcrank(InputStream source) throws IOException {
        return new ProcrankParser().parse(getLines(source));
    }

    /**
     * Parse top output. Exposed for unit testing.
     */
    TopItem parseTop(InputStream source) throws IOException {
        return new TopParser().parse(getLines(source));
    }

    /**
     * Parse dumpsys output. Exposed for unit testing.
     */
    DumpsysItem parseDumpsys(InputStream source) throws IOException {
        return new DumpsysParser().parse(getLines(source));
    }

    CompactMemInfoItem parseCompactMeminfo(InputStream source) throws IOException {
        return new CompactMemInfoParser().parse(getLines(source));
    }

    /**
     * Parse gfxinfo output. Exposed for unit testing.
     */
    GfxInfoItem parseGfxInfo(InputStream source) throws IOException {
        return new GfxInfoParser().parse(getLines(source));
    }

    /**
     * Parse cpuinfo output. Exposed for unit testing.
     */
    CpuInfoItem parseCpuInfo(InputStream source) throws IOException {
        return new CpuInfoParser().parse(getLines(source));
    }

    /**
     * Return the current timestamp. Exposed for unit testing.
     */
    protected Date getCurrentTimestamp() {
        return new Date();
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void setLogSaver(ILogSaver logSaver) {
        // Ignore. This class doesn't save any additional files.
    }

    /**
     * Return the http helper to use. Exposed for unit testing
     */
    IHttpHelper getHttpHelper() {
        return new HttpHelper();
    }

    /**
     * Set the suite instance key. Exposed for subclasses.
     */
    protected void setSuiteInstanceKey(String key) {
        mSuiteInstanceKey = key;
    }

    /**
     * Return the suite instance key. Exposed for subclasses.
     */
    protected String getSuiteInstanceKey() {
        return mSuiteInstanceKey;
    }

    /**
     * Get the description of the run. Exposed for subclasses.
     */
    protected String getDescription() {
        return mDescription;
    }

    /**
     * Set the description of the run. Exposed for subclasses.
     */
    protected void setDescription(String description) {
        mDescription = description;
    }

    protected String getSecondaryHost() {
        if (mSecondaryHost == null) {
            return "";
        }
        return mSecondaryHost;
    }

    private Integer getSecondaryRunId() {
        return mSecondaryRunId;
    }

    private void setSecondaryRunId(Integer id) {
        mSecondaryRunId = id;
    }

    protected String getHost() {
        return mAppEngineHost;
    }

    /**
     * Get the main file from a zipped bugreport {@link InputStream} and return as an
     * {@link InputStream}.
     */
    private InputStream getMainFileSource(InputStream bugreportz) throws IOException {
        File bugreportFile = null;
        File mainFile = null;
        Bugreport br = null;
        try {
            bugreportFile = FileUtil.createTempFile("bugreport", ".zip");
            FileUtil.writeToFile(bugreportz, bugreportFile);
            br = new Bugreport(bugreportFile, true);
            mainFile = br.getMainFile();
            if (mainFile == null) {
                throw new IOException("main file not found in bugreport");
            }
            return new FileInputStream(mainFile);
        } finally {
            // Bugreport.close() will delete the underlying bugreport file
            StreamUtil.close(br);
            FileUtil.deleteFile(mainFile);
        }
    }
}
